###### STD for Reset language
# This file is designed monolithic to be easy to copy and include in any
# project. Contains everything to create anything.
######

### Constants
## Boolean values
FALSE => 0;
TRUE => 1;
## Null value
NULL => 0;
## EOF value
EOF => -1;

### Useful functions
## panic - show panic message and quit
# a0 - message
panic : (a0) {
  # Printing message
  syscall(4, 1, "PANIC: ", 7);
  a0 = a0 ? a0 : "Some function generated panic";
  syscall(4, 1, a0, strlen(a0));
  syscall(4, 1, "\n", 1);
  # Exitting
  exit(1);
}

## assert - make an assertion
# a0 - condition
# a1 - message
assert : (a0, a1) {
  # Checking for condition to be NULL
  if (!a0) {
    # Printing message
    syscall(4, 1, "ASSERT: ", 8);
    a1 = a1 ? a1 : "Some function made assertion";
    # a1 = "Some function made assertion";
    syscall(4, 1, a1, strlen(a1));
    syscall(4, 1, "\n", 1);
    # Exitting
    exit(1);
  }
}

## max - find maximum integer
# a0 - first integer
# a1 - second integer
# @return maximum integer
max : (a0, a1) { return a0 < a1 ? a1 : a0; }

## min - find minimum integer
# a0 - first integer
# a1 - second integer
# @return minimum integer
min : (a0, a1) { return a0 > a1 ? a1 : a0; }

### System calls
## SYS_exit - exit with code
# a0 - exit code
SYS_exit => 1;
exit : (a0) { syscall(SYS_exit, a0); }

## SYS_read - read from file
# a0 - file
# a1 - buffer
# a2 - count
# @return read count
SYS_read => 3;
read : (a0, a1, a2) { return syscall(SYS_read, a0, a1, a2); }

## SYS_write - write to file
# a0 - file
# a1 - buffer
# a2 - count
# @return write count
SYS_write => 4;
write : (a0, a1, a2) { return syscall(SYS_write, a0, a1, a2); }

## SYS_open - open file
# a0 - path
# a1 - flags
# a2 - mode
# @return fd or error
SYS_open => 5;
open : (a0, a1, a2) { return syscall(SYS_open, a0, a1, a2); }

## SYS_close - close file
# a0 - fd
# @return result code
SYS_close => 6;
close : (a0) { return syscall(SYS_close, a0); }

## SYS_brk - set heap segment limit
# a0 - address or NULL
# @return current heap limit
SYS_brk => 45;
brk : (a0) { return syscall(SYS_brk, a0); }

#### Memory Manager Module
### Constants
## Align size
MMM_TLSF_ALIGN_SIZE_LOG2     => 2;
MMM_TLSF_ALIGN_SIZE          => 1 << MMM_TLSF_ALIGN_SIZE_LOG2;
## Second level index
MMM_TLSF_SL_INDEX_COUNT_LOG2 => 5;
MMM_TLSF_SL_INDEX_COUNT      => 1 << MMM_TLSF_SL_INDEX_COUNT_LOG2;
## First level index
# Maximum first level index
MMM_TLSF_FL_INDEX_MAX        => 30;
# First level shift
MMM_TLSF_FL_INDEX_SHIFT      => MMM_TLSF_SL_INDEX_COUNT_LOG2 + MMM_TLSF_ALIGN_SIZE_LOG2;
MMM_TLSF_FL_INDEX_COUNT      => MMM_TLSF_FL_INDEX_MAX - MMM_TLSF_FL_INDEX_SHIFT + 1;
## Small block size
MMM_TLSF_SMALL_BLOCK         => 1 << MMM_TLSF_FL_INDEX_SHIFT;
### Variables
# Current sbrk heap limit
sbrk_current : NULL;
default_memory_pool : NULL;

### Helper functions
## sbrk - increment heap segment limit
# a0 - size
# @return previous heap limit
sbrk : (a0) {
  if (!sbrk_current) sbrk_current = brk(NULL);
  if (a0 <= 0) return sbrk_current;
  sbrk_current += a0;
  brk(sbrk_current);
  return sbrk_current - a0;
}

## ffs - find first bit set in number
# a0 - number
# @return bit index numbered from 0
ffs : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsrl %eax, %eax;
  }
}

## fls - find last bit set in number
# a0 - number
# @return bit index numbered from 0
fls : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsfl %eax, %eax;
  }
}

## align_up - align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_up : (a0, a1) {
  return (a0 + a1 - 1) & ~(a1 - 1);
}

## align_up - align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
  return a0 - (a0 & (a1 - 1));
}

### Memory/String operations
## Fill memory block with value (char)
# a0 - value
# a1 - address
# a2 - size
memset : (a0, a1, a2) {
  # x0 - pos
  allocate(1);
  x0 = 0;
  # Writing value to memory block
  while (x0 < a2) {
    # Writing byte
    writechar(a1, x0, a0);
    # Moving to next byte
    x0 = x0 + 1;
  }
}

## Copy data from one memory block to another
# a0 - src
# a1 - dest
# a2 - size
memcpy : (a0, a1, a2) {
  # x0 - pos
  allocate(1);
  x0 = 0;
  while (x0 < a2) {
    # Writing byte
    writechar(a1, x0, readchar(a0, x0));
    # Moving to next byte
    x0 = x0 + 1;
  }
}

## Get length of string
# a0 - string
# @return string length
strlen : (a0) {
  # x0 - string length
  allocate(1);
  x0 = 0;
  # While char is not NULL, incrementing length
  while (readchar(a0, x0) != '\0') { x0 = x0 + 1; }
  return x0;
}

## Unsigned int to string
# a0 - value
# a1 - result buffer
# a2 - base
utoa_digits : "0123456789abcdefghijklmnopqrstuvwxyz";
utoa : (a0, a1, a2) {
  # x0 - i
  # x1 - j
  # x2 - tmp
  allocate(3);
  x0 = 0;
  # Converting number to string of digits
  do {
    # Writing needed char to result buffer and moving to next char
    writechar(a1, x0++, readchar(utoa_digits, a0 % a2));
    # Going to next unit
    a0 /= a2;
  } while (a0 != 0);
  # Writing '\0' to the end of string and moving to last string char
  writechar(a1, x0--, '\0');
  # Reversing string
  for (x1 = 0; x1 < x0; x0--, x1++) {
    # Fetching temporary char
    x2 = readchar(a1, x1);
    # Writing from end to start
    writechar(a1, x1, readchar(a1, x0));
    # Writing temporary char to end
    writechar(a1, x0, x2);
  }
  # Returning result buffer
  return a1;
}

### TLSF structure
# 16 bytes                                              - null block
# 4 bytes                                               - first level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT                           - second level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT - matrix with free blocks
MMM_TLSF_STRUCT_BLOCK  => 0;
MMM_TLSF_STRUCT_FL_MAP => 4;
MMM_TLSF_STRUCT_SL_MAP => 5;
MMM_TLSF_STRUCT_MATRIX => 5 + MMM_TLSF_FL_INDEX_COUNT;
MMM_TLSF_STRUCT_SIZE   => 4 * (MMM_TLSF_STRUCT_MATRIX + MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT);

### TLSF block header structure
MMM_TLSF_BLOCK_STRUCT_SIZE     => 16;
MMM_TLSF_BLOCK_STRUCT_OFFSET   => 8;
MMM_TLSF_BLOCK_STRUCT_OVERHEAD => 4;
# 4 bytes - pointer to previous block header
# 4 bytes - size of block + bits for availability of previous/this block
# 4 bytes - pointer to previous free block header (here starts data if used)
# 4 bytes - pointer to next free block header
MMM_TLSF_BLOCK_PREV          => 0;
MMM_TLSF_BLOCK_SIZE          => 1;
MMM_TLSF_BLOCK_SIZE_MASK     => 0xfffffffc;
MMM_TLSF_BLOCK_SIZE_MIN      => MMM_TLSF_BLOCK_STRUCT_SIZE - MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
MMM_TLSF_BLOCK_SIZE_MAX      => 1 << MMM_TLSF_STRUCT_FL_MAP;
MMM_TLSF_BLOCK_FREE_BIT      => 1 << 0;
MMM_TLSF_BLOCK_PREV_FREE_BIT => 1 << 1;
MMM_TLSF_BLOCK_BIT_MASK      => 0x00000002;
MMM_TLSF_BLOCK_DATA          => 2;
MMM_TLSF_BLOCK_PREV_FREE     => 2;
MMM_TLSF_BLOCK_NEXT_FREE     => 3;

### TLSF pool header structure
MMM_TLSF_POOL_OVERHEAD => 2 * MMM_TLSF_BLOCK_STRUCT_OVERHEAD;

## get_new_area - get new memory area
# a0 - size
# @return area address
DEFAULT_AREA_SIZE => 0x1000;
get_new_area : (a0) {
  # x0 - area
  allocate(1);
  # Fetching area address
  x0 = sbrk(NULL);
  # If allocated successfully, returning area address
  if (sbrk(a0) != 0xffffffff) return x0;
  return NULL;
}

### TLSF block functions
## mmm_tlsf_block_size - get block size
# a0 - block
# @return block size
mmm_tlsf_block_size : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_SIZE_MASK;
}

## mmm_tlsf_can_block_split - can block split by size?
# a0 - block
# a1 - size
# @return can block split
mmm_tlsf_can_block_split : (a0, a1) {
  return mmm_tlsf_block_size(a0) >= MMM_TLSF_BLOCK_STRUCT_SIZE + a1;
}

## mmm_tlsf_set_block_size - set block size
# a0 - block
# a1 - size
mmm_tlsf_set_block_size : (a0, a1) {
  # x0 - bits
  allocate(1);
  # Fetching bits
  x0 = a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_BIT_MASK;
  # Setting bits to new size
  a0[MMM_TLSF_BLOCK_SIZE] = a1 | x0;
}

## mmm_tlsf_is_block_free - is block free?
# a0 - block
# @return is block free
mmm_tlsf_is_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_set_block_free - set block free bit
# a0 - block
mmm_tlsf_set_block_free : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] |= MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_set_block_used - unset block free bit
# a0 - block
mmm_tlsf_set_block_used : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] &= ~MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_is_prev_block_free - is previous block free?
# a0 - block
# @return is previous block free
mmm_tlsf_is_prev_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_set_prev_block_free - set previous block free bit
# a0 - block
mmm_tlsf_set_prev_block_free : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] |= MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_set_prev_block_used - unset previous block free bit
# a0 - block
mmm_tlsf_set_prev_block_used : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] &= ~MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_is_block_last - is block last?
# a0 - block
# @return is block last
mmm_tlsf_is_block_last : (a0) {
  return mmm_tlsf_block_size(a0) == 0;
}

## mmm_tlsf_ptr_to_block - get block from data pointer
# a0 - pointer
# @return block
mmm_tlsf_ptr_to_block : (a0) {
  return a0 - MMM_TLSF_BLOCK_STRUCT_OFFSET;
}

## mmm_tlsf_block_to_ptr - get data pointer from block
# a0 - block
# @return data pointer
mmm_tlsf_block_to_ptr : (a0) {
  return a0 + MMM_TLSF_BLOCK_STRUCT_OFFSET;
}

## mmm_tlsf_prev_block - get previous block
# a0 - block
# @return previous block
mmm_tlsf_prev_block : (a0) {
  assert(mmm_tlsf_is_prev_block_free(a0), "Previous TLSF block must be free");
  return a0[MMM_TLSF_BLOCK_PREV];
}

## mmm_tlsf_next_block - get next block
# a0 - block
# @return next block
mmm_tlsf_next_block : (a0) {
  assert(!mmm_tlsf_is_block_last(a0), "TLSF block must be non-last");
  return a0 + mmm_tlsf_block_size(a0) + MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
}

## mmm_tlsf_link_next_block - get and link next block
# a0 - block
# @return next block
mmm_tlsf_link_next_block : (a0) {
  # x0 - next block
  allocate(1);
  # Fetching next block
  x0 = mmm_tlsf_next_block(a0);
  # Linking blocks
  x0[MMM_TLSF_BLOCK_PREV] = a0;
  # Returning next block
  return x0;
}

## mmm_tlsf_mark_block_free - mark block as free
# a0 - block
mmm_tlsf_mark_block_free : (a0) {
  # x0 - next block
  allocate(1);
  # Fetching next block
  x0 = mmm_tlsf_next_block(a0);
  # Setting flags
  mmm_tlsf_set_prev_block_free(x0);
  mmm_tlsf_set_block_free(a0);
}

## mmm_tlsf_mark_block_used - mark block as used
# a0 - block
mmm_tlsf_mark_block_used : (a0) {
  # x0 - next block
  allocate(1);
  # Fetching next block
  x0 = mmm_tlsf_next_block(a0);
  # Setting flags
  mmm_tlsf_set_prev_block_used(x0);
  mmm_tlsf_set_block_used(a0);
}

### TLSF utility functions
## mmm_tlsf_mapping_insert - compute first and second level indices
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_insert : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  allocate(2);
  # Calculating first level and second level indices
  if (a0 < MMM_TLSF_SMALL_BLOCK) {
    x0 = 0;
    x1 = a0 / (MMM_TLSF_SMALL_BLOCK / MMM_TLSF_SL_INDEX_COUNT);
  } else {
    x0 = ffs(a0);
    x1 = (a0 >> (x0 - MMM_TLSF_SL_INDEX_COUNT_LOG2)) ^ MMM_TLSF_SL_INDEX_COUNT;
    x0 -= MMM_TLSF_FL_INDEX_SHIFT - 1;
  }
  # Storing results to pointers
  *a1 = x0;
  *a2 = x1;
}

## mmm_tlsf_mapping_search - compute first and second level indices with round up
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_search : (a0, a1, a2) {
  if (a0 >= MMM_TLSF_SMALL_BLOCK)
    a0 += (1 << fls(a0) - MMM_TLSF_SL_INDEX_COUNT_LOG2) - 1;
  mmm_tlsf_mapping_insert(a0, a1, a2);
}

## mmm_tlsf_find_suitable_block - find a suitable free block
# a0 - TLSF structure
# a1 - first level index pointer
# a2 - second level index pointer
# @return block header
mmm_tlsf_find_suitable_block : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  # x2 - first level bitmap
  # x3 - second level bitmap
  allocate(4);
  # Fetching first level and second level indices
  x0 = *a1;
  x1 = *a2;
  # Fetching second level bitmap
  x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0] & (0xffffffff << x1);
  # If second level bitmap is NULL
  if (!x3) {
    # Then no block exists. Search in the next largest first-level list
    x2 = a0[MMM_TLSF_STRUCT_FL_MAP] & (0xffffffff << (x0 + 1));
    # If first level bitmap is NULL, no free blocks available
    if (!x2) return NULL;
    # We have free blocks, calculating first level index for them
    x0 = ffs(x2);
    *a1 = x0;
    # Calculating second level bitmap
    x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0];
  }
  # Calculating second level index
  assert(x3, "Second level bitmap is NULL");
  x1 = ffs(x3);
  *a2 = x1;
  # Returning first block in free list
  return a0[MMM_TLSF_STRUCT_MATRIX + x0 * MMM_TLSF_SL_INDEX_COUNT + x1];
}

## mmm_tlsf_remove_free_block - remove free block from matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_remove_free_block : (a0, a1, a2, a3) {
  # x0 - previous free block
  # x1 - next free block
  allocate(2);
  # Fetching free blocks
  x0 = a1[MMM_TLSF_BLOCK_PREV_FREE];
  x1 = a1[MMM_TLSF_BLOCK_NEXT_FREE];
  assert(x0, "Previous free block cannot be NULL");
  assert(x1, "Next free block cannot be NULL");
  # Updating free blocks
  x0[MMM_TLSF_BLOCK_NEXT_FREE] = x1;
  x1[MMM_TLSF_BLOCK_PREV_FREE] = x0;
  # If block is the head of the free list, set new head
  if (a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] == a1) {
    # New head is next free block
    a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = x1;
    # If the new head is NULL, clear second level bitmap
    if (x1 == a0) {
      # Clearing second level bitmap
      a0[MMM_TLSF_STRUCT_SL_MAP + a2] &= ~(1 << a3);
      # If second level bitmap is NULL, clear first level bitmap
      if (!a0[MMM_TLSF_STRUCT_SL_MAP + a2])
        a0[MMM_TLSF_STRUCT_FL_MAP] &= ~(1 << a2);
    }
  }
}

## mmm_tlsf_insert_free_block - insert free block to matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_insert_free_block : (a0, a1, a2, a3) {
  # x0 - current free block
  allocate(1);
  # Fetching current free list head
  x0 = a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3];
  assert(x0, "Free list cannot have a NULL entry");
  assert(a1, "Cannot insert a null entry into the free list");
  # Updating free block
  a1[MMM_TLSF_BLOCK_PREV_FREE] = a0;
  a1[MMM_TLSF_BLOCK_NEXT_FREE] = x0;
  x0[MMM_TLSF_BLOCK_PREV_FREE] = a1;
  # Making new block a head of free blocks list
  a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = a1;
  # Setting first level bitmap
  a0[MMM_TLSF_STRUCT_FL_MAP] |= 1 << a2;
  # Setting second level bitmap
  a0[MMM_TLSF_STRUCT_SL_MAP + a2] |= 1 << a3;
}

## mmm_tlsf_remove_block - remove block from matrix
# a0 - TLSF structure
# a1 - block
mmm_tlsf_remove_block : (a0, a1) {
  # x0 - first level index
  # x1 - second level index
  allocate(2);
  # Fetching first level and second level indices
  mmm_tlsf_mapping_insert(mmm_tlsf_block_size(a1), &x0, &x1);
  mmm_tlsf_remove_free_block(a0, a1, x0, x1);
}

## mmm_tlsf_insert_block - insert block to matrix
# a0 - TLSF structure
# a1 - block
mmm_tlsf_insert_block : (a0, a1) {
  # x0 - first level index
  # x1 - second level index
  allocate(2);
  # Fetching first level and second level indices
  mmm_tlsf_mapping_insert(mmm_tlsf_block_size(a1), &x0, &x1);
  mmm_tlsf_insert_free_block(a0, a1, x0, x1);
}

## mmm_tlsf_split_block - split block by size
# a0 - block
# a1 - size
# @return remaining block
mmm_tlsf_split_block : (a0, a1) {
  # x0 - remaining block
  # x1 - remaining size
  allocate(2);
  # Fetching remaining block pointer
  x0 = a0 + MMM_TLSF_BLOCK_STRUCT_OFFSET + a1 - MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
  # Fetching remaining block size
  x1 = mmm_tlsf_block_size(a0) - a1 - MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
  # TODO: make assert for alignment of address
  # Setting size for blocks
  mmm_tlsf_set_block_size(a0, a1);
  mmm_tlsf_set_block_size(x0, x1);
  assert(mmm_tlsf_block_size(x0) >= MMM_TLSF_BLOCK_SIZE_MIN, "Block split with incorrect size");
  # Marking remaining block as free
  mmm_tlsf_set_block_free(x0);
  # Returning remaining block
  return x0;
}

## mmm_tlsf_join_blocks - join blocks together
# a0 - prev block
# a1 - block
# @return joined previous block
mmm_tlsf_join_blocks : (a0, a1) {
  assert(!mmm_tlsf_is_block_last(a0), "Previous TLSF block can't be last");
  a0[MMM_TLSF_BLOCK_SIZE] += mmm_tlsf_block_size(a1) + MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
  # Linking next block
  mmm_tlsf_link_next_block(a0);
  # Returning joined block
  return a0;
}

## mmm_tlsf_merge_prev_block - merge block with previous
# a0 - TLSF structure
# a1 - block
mmm_tlsf_merge_prev_block : (a0, a1) {
  # x0 - previous block
  allocate(1);
  # Merging only if previous block is free
  if (mmm_tlsf_is_prev_block_free(a1)) {
    # Fetching previous block
    x0 = mmm_tlsf_prev_block(a1);
    assert(x0, "Previous TLSF block can't be NULL");
    assert(mmm_tlsf_is_block_free(x0), "Previous TLSF block is not free though marked as such");
    # Removing previous block from matrix
    mmm_tlsf_remove_block(a0, x0);
    # Joining blocks
    a1 = mmm_tlsf_join_blocks(x0, a1);
  }
  # Returning block
  return a1;
}

## mmm_tlsf_merge_next_block - merge block with next
# a0 - TLSF structure
# a1 - block
mmm_tlsf_merge_next_block : (a0, a1) {
  # x0 - next block
  allocate(1);
  # Fetching new block
  x0 = mmm_tlsf_next_block(a1);
  assert(x0, "Next TLSF block can't be NULL");
  # Merging only if next block is free
  if (mmm_tlsf_is_block_free(x0)) {
    assert(!mmm_tlsf_is_block_last(a1), "Previous block can't be last");
    # Removing next block from matrix
    mmm_tlsf_remove_block(a0, x0);
    # Joining blocks
    a1 = mmm_tlsf_join_blocks(a1, x0);
  }
  # Returning block
  return a1;
}

## mmm_tlsf_trim_free_block - trim space from end of free block
# a0 - TLSF structure
# a1 - block
# a2 - size
mmm_tlsf_trim_free_block : (a0, a1, a2) {
  # x0 - remaining block
  allocate(1);
  assert(mmm_tlsf_is_block_free(a1), "TLSF block must be free");
  # We can trim only if we can split block
  if (mmm_tlsf_can_block_split(a1, a2)) {
    # Splitting block
    x0 = mmm_tlsf_split_block(a1, a2);
    # Linking block
    mmm_tlsf_link_next_block(a1);
    # Setting previous block free
    mmm_tlsf_set_prev_block_free(x0);
    # Inserting block in matrix
    mmm_tlsf_insert_block(a0, x0);
  }
}

