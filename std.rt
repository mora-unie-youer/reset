###### STD for Reset language
# This file is designed monolithic to be easy to copy and include in any
# project. Contains everything to create anything.
######

### Constants
## Boolean values
FALSE => 0;
TRUE => 1;
## Null value
NULL => 0;
## EOF value
EOF => -1;

### Useful functions
## panic - show panic message and quit
# a0 - message
panic : (a0) {
  # Printing message
  syscall(4, 1, "PANIC: ", 7);
  a0 = a0 ? a0 : "Some function generated panic";
  syscall(4, 1, a0, strlen(a0));
  syscall(4, 1, "\n", 1);
  # Exitting
  exit(1);
}

## assert - make an assertion
# a0 - condition
# a1 - message
assert : (a0, a1) {
  # Checking for condition to be NULL
  if (!a0) {
    # Printing message
    syscall(4, 1, "ASSERT: ", 8);
    a1 = a1 ? a1 : "Some function made assertion";
    # a1 = "Some function made assertion";
    syscall(4, 1, a1, strlen(a1));
    syscall(4, 1, "\n", 1);
    # Exitting
    exit(1);
  }
}

## max - find maximum integer
# a0 - first integer
# a1 - second integer
# @return maximum integer
max : (a0, a1) { return a0 < a1 ? a1 : a0; }

## min - find minimum integer
# a0 - first integer
# a1 - second integer
# @return minimum integer
min : (a0, a1) { return a0 > a1 ? a1 : a0; }

### System calls
## SYS_exit - exit with code
# a0 - exit code
SYS_exit => 1;
exit : (a0) { syscall(SYS_exit, a0); }

## SYS_brk - set heap segment limit
# a0 - address or NULL
# @return current heap limit
SYS_brk => 45;
brk : (a0) { return syscall(SYS_brk, a0); }

#### Memory Manager Module
### Constants
## Align size
MMM_TLSF_ALIGN_SIZE_LOG2     => 2;
MMM_TLSF_ALIGN_SIZE          => 1 << MMM_TLSF_ALIGN_SIZE_LOG2;
## Second level index
MMM_TLSF_SL_INDEX_COUNT_LOG2 => 5;
MMM_TLSF_SL_INDEX_COUNT      => 1 << MMM_TLSF_SL_INDEX_COUNT_LOG2;
## First level index
# Maximum first level index
MMM_TLSF_FL_INDEX_MAX        => 30;
# First level shift
MMM_TLSF_FL_INDEX_SHIFT      => MMM_TLSF_SL_INDEX_COUNT_LOG2 + MMM_TLSF_ALIGN_SIZE_LOG2;
MMM_TLSF_FL_INDEX_COUNT      => MMM_TLSF_FL_INDEX_MAX - MMM_TLSF_FL_INDEX_SHIFT + 1;
## Small block size
MMM_TLSF_SMALL_BLOCK         => 1 << MMM_TLSF_FL_INDEX_SHIFT;
### Variables
# Current sbrk heap limit
sbrk_current : NULL;
default_memory_pool : NULL;

### Helper functions
## sbrk - increment heap segment limit
# a0 - size
# @return previous heap limit
sbrk : (a0) {
  if (!sbrk_current) sbrk_current = brk(NULL);
  if (a0 <= 0) return sbrk_current;
  sbrk_current += a0;
  brk(sbrk_current);
  return sbrk_current - a0;
}

## ffs - find first bit set in number
# a0 - number
# @return bit index numbered from 0
ffs : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsrl %eax, %eax;
  }
}

## fls - find last bit set in number
# a0 - number
# @return bit index numbered from 0
fls : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsfl %eax, %eax;
  }
}

## align_up - align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_up : (a0, a1) {
  return (a0 + a1 - 1) & ~(a1 - 1);
}

## align_up - align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
  return a0 - (a0 & (a1 - 1));
}

### TLSF structure
# 16 bytes                                              - null block
# 4 bytes                                               - first level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT                           - second level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT - matrix with free blocks
MMM_TLSF_STRUCT_BLOCK  => 0;
MMM_TLSF_STRUCT_FL_MAP => 4;
MMM_TLSF_STRUCT_SL_MAP => 5;
MMM_TLSF_STRUCT_MATRIX => 5 + MMM_TLSF_FL_INDEX_COUNT;
MMM_TLSF_STRUCT_SIZE   => 4 * (MMM_TLSF_STRUCT_MATRIX + MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT);

### TLSF block header structure
MMM_TLSF_BLOCK_STRUCT_SIZE     => 16;
MMM_TLSF_BLOCK_STRUCT_OFFSET   => 8;
MMM_TLSF_BLOCK_STRUCT_OVERHEAD => 4;
# 4 bytes - pointer to previous block header
# 4 bytes - size of block + bits for availability of previous/this block
# 4 bytes - pointer to previous free block header (here starts data if used)
# 4 bytes - pointer to next free block header
MMM_TLSF_BLOCK_PREV          => 0;
MMM_TLSF_BLOCK_SIZE          => 1;
MMM_TLSF_BLOCK_SIZE_MASK     => 0xfffffffc;
MMM_TLSF_BLOCK_SIZE_MIN      => MMM_TLSF_BLOCK_STRUCT_SIZE - MMM_TLSF_BLOCK_STRUCT_OVERHEAD;
MMM_TLSF_BLOCK_SIZE_MAX      => 1 << MMM_TLSF_STRUCT_FL_MAP;
MMM_TLSF_BLOCK_FREE_BIT      => 1 << 0;
MMM_TLSF_BLOCK_PREV_FREE_BIT => 1 << 1;
MMM_TLSF_BLOCK_BIT_MASK      => 0x00000002;
MMM_TLSF_BLOCK_DATA          => 2;
MMM_TLSF_BLOCK_PREV_FREE     => 2;
MMM_TLSF_BLOCK_NEXT_FREE     => 3;

### TLSF block functions
## mmm_tlsf_block_size - get block size
# a0 - block
# @return block size
mmm_tlsf_block_size : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_SIZE_MASK;
}

## mmm_tlsf_set_block_size - set block size
# a0 - block
# a1 - size
mmm_tlsf_set_block_size : (a0, a1) {
  # x0 - bits
  allocate(1);
  # Fetching bits
  x0 = a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_BIT_MASK;
  # Setting bits to new size
  a0[MMM_TLSF_BLOCK_SIZE] = a1 | x0;
}

## mmm_tlsf_is_block_free - is block free?
# a0 - block
# @return is block free
mmm_tlsf_is_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_set_block_free - set block free bit
# a0 - block
mmm_tlsf_set_block_free : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] |= MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_set_block_used - unset block free bit
# a0 - block
mmm_tlsf_set_block_used : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] &= ~MMM_TLSF_BLOCK_FREE_BIT;
}

## mmm_tlsf_is_prev_block_free - is previous block free?
# a0 - block
# @return is previous block free
mmm_tlsf_is_prev_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_set_prev_block_free - set previous block free bit
# a0 - block
mmm_tlsf_set_prev_block_free : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] |= MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_set_prev_block_used - unset previous block free bit
# a0 - block
mmm_tlsf_set_prev_block_used : (a0) {
  a0[MMM_TLSF_BLOCK_SIZE] &= ~MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

## mmm_tlsf_is_block_last - is block last?
# a0 - block
# @return is block last
mmm_tlsf_is_block_last : (a0) {
  return mmm_tlsf_block_size(a0) == 0;
}

## mmm_tlsf_ptr_to_block - get block from data pointer
# a0 - pointer
# @return block
mmm_tlsf_ptr_to_block : (a0) {
  return a0 - MMM_TLSF_BLOCK_STRUCT_OFFSET;
}

## mmm_tlsf_block_to_ptr - get data pointer from block
# a0 - block
# @return data pointer
mmm_tlsf_block_to_ptr : (a0) {
  return a0 + MMM_TLSF_BLOCK_STRUCT_OFFSET;
}

### TLSF utility functions
## mmm_tlsf_mapping_insert - compute first and second level indices
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_insert : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  allocate(2);
  # Calculating first level and second level indices
  if (a0 < MMM_TLSF_SMALL_BLOCK) {
    x0 = 0;
    x1 = a0 / (MMM_TLSF_SMALL_BLOCK / MMM_TLSF_SL_INDEX_COUNT);
  } else {
    x0 = ffs(a0);
    x1 = (a0 >> (x0 - MMM_TLSF_SL_INDEX_COUNT_LOG2)) ^ MMM_TLSF_SL_INDEX_COUNT;
    x0 -= MMM_TLSF_FL_INDEX_SHIFT - 1;
  }
  # Storing results to pointers
  *a1 = x0;
  *a2 = x1;
}

## mmm_tlsf_mapping_search - compute first and second level indices with round up
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_search : (a0, a1, a2) {
  if (a0 >= MMM_TLSF_SMALL_BLOCK)
    a0 += (1 << fls(a0) - MMM_TLSF_SL_INDEX_COUNT_LOG2) - 1;
  mmm_tlsf_mapping_insert(a0, a1, a2);
}

## mmm_tlsf_find_suitable_block - find a suitable free block
# a0 - TLSF structure
# a1 - first level index pointer
# a2 - second level index pointer
# @return block header
mmm_tlsf_find_suitable_block : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  # x2 - first level bitmap
  # x3 - second level bitmap
  allocate(4);
  # Fetching first level and second level indices
  x0 = *a1;
  x1 = *a2;
  # Fetching second level bitmap
  x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0] & (0xffffffff << x1);
  # If second level bitmap is NULL
  if (!x3) {
    # Then no block exists. Search in the next largest first-level list
    x2 = a0[MMM_TLSF_STRUCT_FL_MAP] & (0xffffffff << (x0 + 1));
    # If first level bitmap is NULL, no free blocks available
    if (!x2) return NULL;
    # We have free blocks, calculating first level index for them
    x0 = ffs(x2);
    *a1 = x0;
    # Calculating second level bitmap
    x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0];
  }
  # Calculating second level index
  assert(x3, "Second level bitmap is NULL");
  x1 = ffs(x3);
  *a2 = x1;
  # Returning first block in free list
  return a0[MMM_TLSF_STRUCT_MATRIX + x0 * MMM_TLSF_SL_INDEX_COUNT + x1];
}

## mmm_tlsf_remove_free_block - remove free block from matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_remove_free_block : (a0, a1, a2, a3) {
  # x0 - previous free block
  # x1 - next free block
  allocate(2);
  # Fetching free blocks
  x0 = a1[MMM_TLSF_BLOCK_PREV_FREE];
  x1 = a1[MMM_TLSF_BLOCK_NEXT_FREE];
  assert(x0, "Previous free block cannot be NULL");
  assert(x1, "Next free block cannot be NULL");
  # Updating free blocks
  x0[MMM_TLSF_BLOCK_NEXT_FREE] = x1;
  x1[MMM_TLSF_BLOCK_PREV_FREE] = x0;
  # If block is the head of the free list, set new head
  if (a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] == a1) {
    # New head is next free block
    a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = x1;
    # If the new head is NULL, clear second level bitmap
    if (x1 == a0) {
      # Clearing second level bitmap
      a0[MMM_TLSF_STRUCT_SL_MAP + a2] &= ~(1 << a3);
      # If second level bitmap is NULL, clear first level bitmap
      if (!a0[MMM_TLSF_STRUCT_SL_MAP + a2])
        a0[MMM_TLSF_STRUCT_FL_MAP] &= ~(1 << a2);
    }
  }
}

## mmm_tlsf_insert_free_block - insert free block to matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_insert_free_block : (a0, a1, a2, a3) {
  # x0 - current free block
  allocate(1);
  # Fetching current free list head
  x0 = a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3];
  assert(x0, "Free list cannot have a NULL entry");
  assert(a1, "Cannot insert a null entry into the free list");
  # Updating free block
  a1[MMM_TLSF_BLOCK_PREV_FREE] = a0;
  a1[MMM_TLSF_BLOCK_NEXT_FREE] = x0;
  x0[MMM_TLSF_BLOCK_PREV_FREE] = a1;
  # Making new block a head of free blocks list
  a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = a1;
  # Setting first level bitmap
  a0[MMM_TLSF_STRUCT_FL_MAP] |= 1 << a2;
  # Setting second level bitmap
  a0[MMM_TLSF_STRUCT_SL_MAP + a2] |= 1 << a3;
}
