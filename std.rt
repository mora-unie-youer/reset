###### STD for Reset language
# This file is designed monolithic to be easy to copy and include in any
# project. Contains everything to create anything.
######

### Constants
## Boolean values
FALSE => 0;
TRUE => 1;
## Null value
NULL => 0;
## EOF value
EOF => -1;

### System calls
## SYS_exit - exit with code
# a0 - exit code
SYS_exit => 1;
exit : (a0) { syscall(SYS_exit, a0); }

## SYS_brk - set heap segment limit
# a0 - address or NULL
# @return current heap limit
SYS_brk => 45;
brk : (a0) { return syscall(SYS_brk, a0); }

#### Memory Manager Module
### Constants
## Align size
MMM_ALIGN_SIZE_LOG2   => 2;
MMM_ALIGN_SIZE        => 1 << MMM_ALIGN_SIZE_LOG2;
## Second level index
MMM_SL_INDEX_MAX_LOG2 => 5;
MMM_SL_INDEX_MAX      => 1 << MMM_SL_INDEX_MAX_LOG2;
## First level index
# Maximum first level index
MMM_FL_INDEX_MAX      => 30;
# First level shift
MMM_FL_INDEX_SHIFT    => MMM_SL_INDEX_MAX_LOG2 + MMM_ALIGN_SIZE_LOG2;
MMM_FL_INDEX_COUNT    => MMM_FL_INDEX_MAX - MMM_FL_INDEX_SHIFT + 1;
## Small block size
MMM_SMALL_BLOCK       => 1 << MMM_FL_INDEX_SHIFT;
### Variables
# Current sbrk heap limit
sbrk_current : NULL;
default_memory_pool : NULL;

### Helper functions
## sbrk - increment heap segment limit
# a0 - size
# @return previous heap limit
sbrk : (a0) {
  if (!sbrk_current) sbrk_current = brk(NULL);
  if (a0 <= 0) return sbrk_current;
  sbrk_current += a0;
  brk(sbrk_current);
  return sbrk_current - a0;
}

## ffs - find first bit set in number
# a0 - number
# @return bit index numbered from 0
ffs : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsrl %eax, %eax;
  }
}

## fls - find last bit set in number
# a0 - number
# @return bit index numbered from 0
fls : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsfl %eax, %eax;
  }
}

### TLSF structure
# 4 bytes                                   - linked list holding all existing areas
# 4 bytes                                   - first level bitmap
# 4 * MMM_FL_INDEX_COUNT                    - second level bitmap
# 4 * MMM_FL_INDEX_COUNT * MMM_SL_INDEX_MAX - matrix with free blocks
MMM_TLSF_STRUCT_AREA   => 0;
MMM_TLSF_STRUCT_FL_MAP => 1;
MMM_TLSF_STRUCT_SL_MAP => 2;
MMM_TLSF_STRUCT_MATRIX => 2 + MMM_FL_INDEX_COUNT;

### TLSF block header structure
# 4 bytes - pointer to previous block header
# 4 bytes - size of block + bits for availability of previous/this block
# 4 bytes - pointer to previous free block header (here starts data if used)
# 4 bytes - pointer to next free block header
MMM_TLSF_BLOCK_PREV          => 0;
MMM_TLSF_BLOCK_SIZE          => 1;
MMM_TLSF_BLOCK_SIZE_MASK     => 0xfffffffc;
MMM_TLSF_BLOCK_FREE_BIT      => 1 << 0;
MMM_TLSF_BLOCK_PREV_FREE_BIT => 1 << 1;
MMM_TLSF_BLOCK_DATA          => 2;
MMM_TLSF_BLOCK_PREV_FREE     => 2;
MMM_TLSF_BLOCK_NEXT_FREE     => 3;

mmm_tlsf_block_size : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_SIZE_MASK;
};

mmm_tlsf_is_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_FREE_BIT;
}

mmm_tlsf_is_prev_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_PREV_FREE_BIT;
}
