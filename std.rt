###### STD for Reset language
# This file is designed monolithic to be easy to copy and include in any
# project. Contains everything to create anything.
######

### Constants
## Boolean values
FALSE => 0;
TRUE => 1;
## Null value
NULL => 0;
## EOF value
EOF => -1;

### System calls
## SYS_exit - exit with code
# a0 - exit code
SYS_exit => 1;
exit : (a0) { syscall(SYS_exit, a0); }

## SYS_brk - set heap segment limit
# a0 - address or NULL
# @return current heap limit
SYS_brk => 45;
brk : (a0) { return syscall(SYS_brk, a0); }

#### Memory Manager Module
### Constants
## Align size
MMM_TLSF_ALIGN_SIZE_LOG2     => 2;
MMM_TLSF_ALIGN_SIZE          => 1 << MMM_TLSF_ALIGN_SIZE_LOG2;
## Second level index
MMM_TLSF_SL_INDEX_COUNT_LOG2 => 5;
MMM_TLSF_SL_INDEX_COUNT      => 1 << MMM_TLSF_SL_INDEX_COUNT_LOG2;
## First level index
# Maximum first level index
MMM_TLSF_FL_INDEX_MAX        => 30;
# First level shift
MMM_TLSF_FL_INDEX_SHIFT      => MMM_TLSF_SL_INDEX_COUNT_LOG2 + MMM_TLSF_ALIGN_SIZE_LOG2;
MMM_TLSF_FL_INDEX_COUNT      => MMM_TLSF_FL_INDEX_MAX - MMM_TLSF_FL_INDEX_SHIFT + 1;
## Small block size
MMM_TLSF_SMALL_BLOCK         => 1 << MMM_TLSF_FL_INDEX_SHIFT;
### Variables
# Current sbrk heap limit
sbrk_current : NULL;
default_memory_pool : NULL;

### Helper functions
## sbrk - increment heap segment limit
# a0 - size
# @return previous heap limit
sbrk : (a0) {
  if (!sbrk_current) sbrk_current = brk(NULL);
  if (a0 <= 0) return sbrk_current;
  sbrk_current += a0;
  brk(sbrk_current);
  return sbrk_current - a0;
}

## ffs - find first bit set in number
# a0 - number
# @return bit index numbered from 0
ffs : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsrl %eax, %eax;
  }
}

## fls - find last bit set in number
# a0 - number
# @return bit index numbered from 0
fls : (a0) {
  asm {
    movl 8(%ebp), %eax;
    bsfl %eax, %eax;
  }
}

## align_up - align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_up : (a0, a1) {
  return (a0 + a1 - 1) & ~(a1 - 1);
}

## align_up - align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
  return a0 - (a0 & (a1 - 1));
}

### TLSF structure
# 4 bytes                                               - linked list holding all existing areas
# 4 bytes                                               - first level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT                           - second level bitmap
# 4 * MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT - matrix with free blocks
MMM_TLSF_STRUCT_AREA   => 0;
MMM_TLSF_STRUCT_FL_MAP => 1;
MMM_TLSF_STRUCT_SL_MAP => 2;
MMM_TLSF_STRUCT_MATRIX => 2 + MMM_TLSF_FL_INDEX_COUNT;
MMM_TLSF_STRUCT_SIZE   => 4 * (MMM_TLSF_STRUCT_MATRIX + MMM_TLSF_FL_INDEX_COUNT * MMM_TLSF_SL_INDEX_COUNT);

### TLSF block header structure
# 4 bytes - pointer to previous block header
# 4 bytes - size of block + bits for availability of previous/this block
# 4 bytes - pointer to previous free block header (here starts data if used)
# 4 bytes - pointer to next free block header
MMM_TLSF_BLOCK_PREV          => 0;
MMM_TLSF_BLOCK_SIZE          => 1;
MMM_TLSF_BLOCK_SIZE_MASK     => 0xfffffffc;
MMM_TLSF_BLOCK_FREE_BIT      => 1 << 0;
MMM_TLSF_BLOCK_PREV_FREE_BIT => 1 << 1;
MMM_TLSF_BLOCK_DATA          => 2;
MMM_TLSF_BLOCK_PREV_FREE     => 2;
MMM_TLSF_BLOCK_NEXT_FREE     => 3;

mmm_tlsf_block_size : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_SIZE_MASK;
}

mmm_tlsf_is_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_FREE_BIT;
}

mmm_tlsf_is_prev_block_free : (a0) {
  return a0[MMM_TLSF_BLOCK_SIZE] & MMM_TLSF_BLOCK_PREV_FREE_BIT;
}

### TLSF utility functions
## mmm_tlsf_mapping_insert - compute first and second level indices
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_insert : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  allocate(2);
  # Calculating first level and second level indices
  if (a0 < MMM_TLSF_SMALL_BLOCK) {
    x0 = 0;
    x1 = a0 / (MMM_TLSF_SMALL_BLOCK / MMM_TLSF_SL_INDEX_COUNT);
  } else {
    x0 = fls(a0);
    x1 = (a0 >> (x0 - MMM_TLSF_SL_INDEX_COUNT_LOG2)) - MMM_TLSF_SL_INDEX_COUNT;
    x0 -= MMM_TLSF_FL_INDEX_SHIFT;
  }
  # Storing results to pointers
  *a1 = x0;
  *a2 = x1;
}

## mmm_tlsf_mapping_search - compute first and second level indices with round up
# a0 - size
# a1 - first level index pointer
# a2 - second level index pointer
mmm_tlsf_mapping_search : (a0, a1, a2) {
  if (a0 >= MMM_TLSF_SMALL_BLOCK)
    a0 += (1 << fls(a0) - MMM_TLSF_SL_INDEX_COUNT_LOG2) - 1;
  mmm_tlsf_mapping_insert(a0, a1, a2);
}

## mmm_tlsf_find_suitable_block - find a suitable free block
# a0 - TLSF structure
# a1 - first level index pointer
# a2 - second level index pointer
# @return block header
mmm_tlsf_find_suitable_block : (a0, a1, a2) {
  # x0 - first level index
  # x1 - second level index
  # x2 - first level bitmap
  # x3 - second level bitmap
  allocate(4);
  # Fetching first level and second level indices
  x0 = *a1;
  x1 = *a2;
  # Fetching second level bitmap
  x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0] & (0xffffffff << x1);
  # If second level bitmap is NULL
  if (!x3) {
    # Then no block exists. Search in the next largest first-level list
    x2 = a0[MMM_TLSF_STRUCT_FL_MAP] & (0xffffffff << (x0 + 1));
    # If first level bitmap is NULL, no free blocks available
    if (!x2) return NULL;
    # We have free blocks, calculating first level index for them
    x0 = ffs(x2);
    # *a1 = x0;
    # Calculating second level bitmap
    x3 = a0[MMM_TLSF_STRUCT_SL_MAP + x0];
  }
  # Calculating second level index
  x1 = ffs(x3);
  # *a2 = x1;
  # Returning first block in free list
  return a0[MMM_TLSF_STRUCT_MATRIX + x0 * MMM_TLSF_SL_INDEX_COUNT + x1];
}

## mmm_tlsf_remove_free_block - remove free block from matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_remove_free_block : (a0, a1, a2, a3) {
  # x0 - previous free block
  # x1 - next free block
  allocate(2);
  # Fetching free blocks
  x0 = a1[MMM_TLSF_BLOCK_PREV_FREE];
  x1 = a1[MMM_TLSF_BLOCK_NEXT_FREE];
  # Updating free blocks
  if (x0) x0[MMM_TLSF_BLOCK_NEXT_FREE] = x1;
  if (x1) x1[MMM_TLSF_BLOCK_PREV_FREE] = x0;
  # If block is the head of the free list, set new head
  if (a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] == a1) {
    # New head is next free block
    a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = x1;
    # If the new head is NULL, clear second level bitmap
    if (!x1) {
      # Clearing second level bitmap
      a0[MMM_TLSF_STRUCT_SL_MAP + a2] &= ~(1 << a3);
      # If second level bitmap is NULL, clear first level bitmap
      if (!a0[MMM_TLSF_STRUCT_SL_MAP + a2])
        a0[MMM_TLSF_STRUCT_FL_MAP] &= ~(1 << a2);
    }
  }
  # Clearing pointers to free blocks
  # a1[MMM_TLSF_BLOCK_PREV_FREE] = NULL;
  # a1[MMM_TLSF_BLOCK_NEXT_FREE] = NULL;
}

## mmm_tlsf_insert_free_block - insert free block to matrix
# a0 - TLSF structure
# a1 - block
# a2 - first level index
# a3 - second level index
mmm_tlsf_insert_free_block : (a0, a1, a2, a3) {
  # x0 - current free block
  allocate(1);
  # Fetching current free list head
  x0 = a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3];
  # Updating free block
  a1[MMM_TLSF_BLOCK_PREV_FREE] = NULL;
  a1[MMM_TLSF_BLOCK_NEXT_FREE] = x0;
  x0[MMM_TLSF_BLOCK_PREV_FREE] = a1;
  # Making new block a head of free blocks list
  a0[MMM_TLSF_STRUCT_MATRIX + a2 * MMM_TLSF_SL_INDEX_COUNT + a3] = a1;
  # Setting first level bitmap
  a0[MMM_TLSF_STRUCT_FL_MAP] |= 1 << a2;
  # Setting second level bitmap
  a0[MMM_TLSF_STRUCT_SL_MAP + a2] |= 1 << a3;
}
