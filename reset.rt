### Useful constants
NULL  => 0;
EOF   => -1;
## Booleans
FALSE => 0;
TRUE  => 1;

### System calls
SYS_exit   => 1;
SYS_read   => 3;
SYS_write  => 4;
SYS_open   => 5;
SYS_close  => 6;
SYS_brk    => 45;
SYS_munmap => 91;
SYS_mmap2  => 192;

### System call functions
## Exit with code
# a0 - exit code
exit : (a0) { syscall(SYS_exit, a0); };

## Read from file
# a0 - file
# a1 - buffer
# a2 - count
# @return read count
read : (a0, a1, a2) { return(syscall(SYS_read, a0, a1, a2)); };

## Write to file
# a0 - file
# a1 - buffer
# a2 - count
# @return write count
write : (a0, a1, a2) { return(syscall(SYS_write, a0, a1, a2)); };

## Open file
# a0 - path
# a1 - flags
# a2 - mode
# @return fd or error
open : (a0, a1, a2) { return(syscall(SYS_open, a0, a1, a2)); };

## Close file
# a0 - fd
# @return result code
close : (a0) { return(syscall(SYS_close, a0)); };

## Set/return heap segment limit
# a0 - address (set) or NULL (return)
# @return current heap limit
brk : (a0) { return(syscall(SYS_brk, a0)); };

## Unmap memory page
# a0 - address
# a1 - size
# @return zero on success, negative on error
munmap : (a0, a1) { return(syscall(SYS_munmap, a0, a1)); };

## Map memory page
# a0 - address
# a1 - size
# a2 - protection flags
# a3 - map flags
# a4 - fd
# a5 - offset
mmap2 : (a0, a1, a2, a3, a4, a5) {
	return(syscall(SYS_mmap2, a0, a1, a2, a3, a4, a5));
};

### Useful functions
## Align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align : (a0, a1) {
	return((a0 + a1 - 1) & ~(a1 - 1));
};

## Align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
	return(a0 - (a0 & (a1 - 1)));
};

### Conversions
## Int to string
# a0 - value
# a1 - result buffer
# a2 - base
itoa_digits : "0123456789abcdefghijklmnopqrstuvwxyz";
itoa : (a0, a1, a2) {
	# x0 - i
	# x1 - j
	# x2 - tmp
	allocate(3);
	x0 = 0;
	x1 = 0;

	# Writing first digit
	writechar(a1, x0, readchar(itoa_digits, a0 % a2));
	# Going to next unit
	a0 = a0 / a2;
	# Going to next char position
	x0 = x0 + 1;

	# Iterating while value is not zero
	while (a0 != 0) {
		# Writing needed char to result buffer
		writechar(a1, x0, readchar(itoa_digits, a0 % a2));
		# Going to next unit
		a0 = a0 / a2;
		# Going to next char position
		x0 = x0 + 1;
	};
	# Writing '\0' to the end of string
	writechar(a1, x0, '\0');
	# Reversing string
	while (x1 < x0) {
		# Starting from penultimate char
		x0 = x0 - 1;
		# Storing char to temp
		x2 = readchar(a1, x1);
		# Moving a1[x0] to a1[x1]
		writechar(a1, x1, readchar(a1, x0));
		# Moving temp to a1[x0]
		writechar(a1, x0, x2);
		# Reversing next chars
		x1 = x1 + 1;
	};
	# Returning result buffer
	return(a1);
};

### Memory Management
## Memory page size
PAGE_SIZE => 4096; # 0x1000
## Memory page status
PAGE_USED => 2147483648; # 0x80000000
## Heap segment start and end
brk_start : NULL;
brk_end   : NULL;
## Memory page list
memory_block : NULL;

## Increment heap segment size
# a0 - increment size (use negative to decrement)
# @return new heap segment limit
sbrk : (a0) {
	# x0 - old limit
	# x1 - new limit
	allocate(2);
	x0 = brk_end;
	# Uninitialized heap
	if (x0 == NULL) {
		x0 = brk(NULL);
		brk_start = x0;
	};
	# Incrementing/decrementing limit
	x1 = x0 + a0;
	# TODO: handle error, when x0 (new brk_end) < brk_start
	# Setting and returning new heap segment limit
	brk_end = x1;
	brk(x1);
	return(x0);
};

## Allocate new memory page
allocate_page : () {
	# x0 - previous heap limit
	# x1 - memory size
	allocate(2);
	# Allocating next page
	x0 = sbrk(PAGE_SIZE);

	# If memory blocks are uninitialized
	if (memory_block == NULL) {
		# Initializing pointers
		memory_block = x0;
		# Initializing first memory block
		memory_block[0] = NULL; # Pointer to previous block
		memory_block[1] = PAGE_SIZE - 8; # Setting size and `not allocated`
	} else {
		x1 = memory_block[1];
		# If last memory block is used
		if (x1 & PAGE_USED) {
			# Creating new memory block
			x0[0] = memory_block; # Points to last block
			x0[1] = PAGE_SIZE - 8; # Setting size and `not allocated`
			memory_block = x0; # Setting new last block
		} else {
			# Memory block is not used, just adding new memory to it
			memory_block[1] = x1 + PAGE_SIZE;
		};
	};
};

## Allocate block
# a0 - block size
# @return address of block
allocate_block : (a0) {
	# x0 - required memory size
	# x1 - memory block
	# x2 - memory block size and status
	# x3 - new memory block
	allocate(4);
	# required size is aligned to 4 bytes
	x0 = align(a0, 4);
label allocate_block_retry;
	# Starting from latest block
	x1 = memory_block;
	# Iterating while we have next memory blocks
	while (x1 != NULL) {
		# Fetching block size and status
		x2 = x1[1];
		# Checking if this block is not used
		if ((x2 & PAGE_USED) == NULL) {
			# Checking if this block perfectly fits -> simply change status
			if (x2 == x0) {
				# Setting used status
				x1[1] = x2 | PAGE_USED;
				# Returning allocated block (skipping 8 bytes)
				return(x1);
			};
			# Checking if this block can be splitted (requested size + header size)
			if (x2 >= x0 + 8) {
				# New free block
				x3 = x1 + x0 + 8;
				x3[0] = x1; # Setting previous block
				x3[1] = x2 - x0 - 8; # Setting new size
				# If x1 is last block -> changing last block
				if (x1 == memory_block) { memory_block = x3; };
				# Decreasing block size and setting used status
				x1[1] = x0 | PAGE_USED;
				return(x1);
			};
		};
		# Iterating with next block
		x1 = x1[0];
	};
	# We are here only if there's no available block. Allocating new page
	allocate_page();
	# Now we have more memory, retrying
	goto &allocate_block_retry;
};

## Try merge block with previous
# a0 - block
merge_block : (a0) {
	# x0 - prev block
	# x1 - status of prev block
	# x2 - status of this block
	allocate(3);
	# Getting block from address
	# Fetching previous block
	x0 = a0[0];
	# Checking if previous block is not null
	if (x0 == NULL) { return; };
	# Fetching statuses
	x1 = x0[1] & PAGE_USED;
	x2 = a0[1] & PAGE_USED;
	# If statuses are not NULL (free) and are not equal - returning
	if (x1) { return; };
	if (x1 != x2) { return; };
	# Merging previous block with this
	x0[1] = x0[1] + a0[1] + 8;
	# Checking if it was last block.
	if (a0 == memory_block) { memory_block = x0; return; };
	# Updating next block, as it wasn't last block
	a0 = x0 + x0[1] + 8;
	a0[0] = x0;
};

## Deallocate block
# a0 - block
deallocate_block : (a0) {
	# x0 - block status/next block
	allocate(1);
	# Fetching block status
	x0 = a0[1] & PAGE_USED;
	# If block is not used - returning
	if (x0 == NULL) { return; };
	# Setting free status
	a0[1] = a0[1] & ~(PAGE_USED);
	# FIXME: segfaults for some reason
	# Try to merge this block
	#merge_block(a0);
	# Try to merge next block
	#if (a0 == memory_block) { return; };
	#merge_block(a0 + a0[1] + 8);
};

## Get block size
# a0 - block
# @return block size
block_size : (a0) { return(a0[1] & ~(PAGE_USED)); };

## Allocate memory
# a0 - size
# @return allocated memory
malloc : (a0) {
	return(allocate_block(a0) + 8);
};

## Allocate cleared memory
# a0 - size
# @return allocated and cleared memory
calloc : (a0) {
	# x0 - address
	allocate(1);
	# Allocating memory
	x0 = malloc(a0);
	# Clearing memory with zeroes
	memset(0, x0, a0);
	return(x0);
};

## Reallocate memory with new size
# a0 - allocated memory
# a1 - new size
# @return new allocated memory
realloc : (a0, a1) {
	# x0 - old size/min size
	# x1 - new allocated memory space
	allocate(2);
	# Fetching old size
	x0 = block_size(a0 - 8);
	# Storing minimal size
	if (a1 < x0) { x0 = a1; };
	# Allocating new memory
	x1 = calloc(x0);
	# Copying data to new memory space
	memcpy(a0, x1, x0);
	# Freeing old memory space
	free(a0);
	return(x1);
};

## Free memory
# a0 - address
free : (a0) {
	deallocate_block(a0 - 8);
};

### Memory/String operations
## Fill memory block with value (char)
# a0 - value
# a1 - address
# a2 - size
memset : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	# Writing value to memory block
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, a0);
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Copy data from one memory block to another
# a0 - src
# a1 - dest
# a2 - size
memcpy : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, readchar(a0, x0));
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Get length of string
# a0 - string
# @return string length
strlen : (a0) {
	# x0 - string length
	allocate(1);
	x0 = 0;
	# While char is not NULL, incrementing length
	while (readchar(a0, x0) != '\0') { x0 = x0 + 1; };
	return(x0);
};

## Copy string
# a0 - src
# a1 - dest
strcpy : (a0, a1) {
	# x0 - pos
	# x1 - char
	allocate(2);
	x0 = 0;
	# Reading char from string
	x1 = readchar(a0, x0);
	# Checking if char is not NULL
	while (x1 != '\0') {
		# Copying char from one string to another
		writechar(a1, x0, x1);
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
	};
	# Writing NULL character
	writechar(a1, x0, '\0');
};

## Compare string
# a0 - first string
# a1 - second string
# @return difference between different chars (0 if strings are equal)
strcmp : (a0, a1) {
	# x0 - pos
	# x1 - char from first string
	# x2 - char from second string
	allocate(3);
	x0 = 0;
	# Reading first chars from strings
	x1 = readchar(a0, x0);
	x2 = readchar(a1, x0);
	# Comparing char by char
	while (x1 != '\0') {
		if (x1 != x2) { return(x1 - x2); };
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
		x2 = readchar(a1, x0);
	};
	# As first string ended, finding the difference between ending chars
	return(x1 - x2);
};

### Tuples
## Allocate tuple
# a0 - size
# @return allocated tuple
allocate_tuple : (a0) { return malloc(4 * a0); };

## Make tuple with 3 values
# a0, a1 - values
# @return tuple
tuple2 : (a0, a1) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(2);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	return(x0);
};

## Make tuple with 3 values
# a0, a1, a2 - values
# @return tuple
tuple3 : (a0, a1, a2) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(3);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	return(x0);
};

## Make tuple with 4 values
# a0, a1, a2, a3 - values
# @return tuple
tuple4 : (a0, a1, a2, a3) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(4);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	return(x0);
};

## Make tuple with 5 values
# a0, a1, a2, a3, a4 - values
# @return tuple
tuple5 : (a0, a1, a2, a3, a4) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(5);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	return(x0);
};

## Make tuple with 7 values
# a0, a1, a2, a3, a4, a5, a6 - values
# @return tuple
tuple7 : (a0, a1, a2, a3, a4, a5, a6) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(7);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	x0[5] = a5;
	x0[6] = a6;
	return(x0);
};

## Make tuple with 8 values
# a0, a1, a2, a3, a4, a5, a6, a7 - values
# @return tuple
tuple8 : (a0, a1, a2, a3, a4, a5, a6, a7) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(7);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	x0[5] = a5;
	x0[6] = a6;
	x0[7] = a7;
	return(x0);
};

### Linked List
## List parts
LIST_NEXT  => 0;
LIST_VALUE => 1;

## Create linked list with value
# a0 - value
# @return list
list : (a0) { return(list_insert(NULL, a0)); };

## Insert value in linked list
# a0 - list
# a1 - value
# @return list with new value
list_insert : (a0, a1) { return(tuple2(a0, a1)); };

## Get next element of linked list
# a0 - list
# @return list with next value
list_next : (a0) { return(a0[LIST_NEXT]); };

## Get value of current element of linked list
# a0 - list
# @return current element value
list_value : (a0) { return(a0[LIST_VALUE]); };

## Remove this element from list
# a0 - list
# @return reduced list
list_pop : (a0) {
	# x0 - list continuation
	allocate(1);
	# Fetching next element
	x0 = list_next(a0);
	# Deallocating current element
	free(a0);
	return(x0);
};

### Vector
## Vector parts
VEC_SIZE => 0;
VEC_CAP  => 1;
VEC_BUF  => 2;

## Create character vector
# a0 - size
# a1 - capacity
# @return character vector
char_vector : (a0, a1) { return(tuple3(a0, a1, calloc(a1))); };

## Create vector
# a0 - size
# a1 - capacity
# @return vector
vector : (a0, a1) { return(tuple3(a0, a1, calloc(4 * a1))); };

## Get vector buffer
# a0 - vector
# @return vector buffer
vector_buffer : (a0) { return(a0[VEC_BUF]); };

## Get vector size
# a0 - vector
# @return vector size
vector_size : (a0) { return(a0[VEC_SIZE]); };

## Reserve more space for char vector buffer
# a0 - char vector
# a1 - new capacity
char_vector_reserve : (a0, a1) {
	# Reserving, if new capacity is bigger
	if (a1 > a0[VEC_CAP]) {
		# Reallocating buffer
		a0[VEC_BUF] = realloc(a0[VEC_BUF], a1);
		# Setting new capacity
		a0[VEC_CAP] = a1;
	};
};

## Reserve more space for vector buffer
# a0 - vector
# a1 - new capacity
vector_reserve : (a0, a1) {
	# Reserving, if new capacity is bigger
	if (a1 > a0[VEC_CAP]) {
		# Reallocating buffer
		a0[VEC_BUF] = realloc(a0[VEC_BUF], 4 * a1);
		# Setting new capacity
		a0[VEC_CAP] = a1;
	};
};

## Resize char vector
# a0 - char vector
# a1 - new size
char_vector_resize : (a0, a1) {
	# Reserving, if required
	if (a1 > a0[VEC_SIZE]) { char_vector_reserve(a0, a1); };
	# Setting new size
	a0[VEC_SIZE] = a1;
};

## Resize vector
# a0 - vector
# a1 - new size
vector_resize : (a0, a1) {
	# Reserving, if required
	if (a1 > a0[VEC_SIZE]) { vector_reserve(a0, a1); };
	# Setting new size
	a0[VEC_SIZE] = a1;
};

## Get value at index in char vector
# a0 - char vector
# a1 - index
# @return char
char_vector_get : (a0, a1) { return(readchar(a0[VEC_BUF], a1)); };

## Get value at index in vector
# a0 - vector
# a1 - index
# @return value
vector_get : (a0, a1) { return(a0[VEC_BUF][a1]); };

## Set value at index in char vector
# a0 - char vector
# a1 - index
# a2 - char
char_vector_set : (a0, a1, a2) { writechar(a0[VEC_BUF], a1, a2); };

## Set value at index in vector
# a0 - vector
# a1 - index
# a2 - value
vector_set : (a0, a1, a2) {
	# x0 - buffer
	allocate(1);
	x0 = a0[VEC_BUF];
	x0[a1] = a2;
};

## Insert value in the end of char vector
# a0 - char vector
# a1 - value
char_vector_push : (a0, a1) {
	# If vector buffer is full, reserving more
	if (a0[VEC_SIZE] == a0[VEC_CAP]) {
		char_vector_reserve(a0, a0[VEC_CAP] * 2);
	};
	# Putting new value
	char_vector_set(a0, a0[VEC_SIZE], a1);
	# Incrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] + 1;
};

## Insert value in the end of vector
# a0 - vector
# a1 - value
vector_push : (a0, a1) {
	# If vector buffer is full, reserving more
	if (a0[VEC_SIZE] == a0[VEC_CAP]) {
		vector_reserve(a0, a0[VEC_CAP] * 2);
	};
	# Putting new value
	vector_set(a0, a0[VEC_SIZE], a1);
	# Incrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] + 1;
};

## Remove and return last value from char vector
# a0 - char vector
# @return char
char_vector_pop : (a0) {
	# Decrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] - 1;
	# Returning the value
	return(char_vector_get(a0, a0[VEC_SIZE]));
};

## Remove and return last value from vector
# a0 - vector
# @return value
vector_pop : (a0) {
	# Decrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] - 1;
	# Returning the value
	return(vector_get(a0, a0[VEC_SIZE]));
};

## Destroy vector
# a0 - vector
vector_destroy : (a0) {
	# Deallocating buffer
	free(a0[VEC_BUF]);
	# Deallocating vector
	free(a0);
};

### I/O
## Open flags
O_RDONLY => 0;
O_WRONLY => 1;
O_RDWR   => 2;
O_CREAT  => 64;
O_TRUNC  => 512;
O_APPEND => 1024;
## Parts of I/O channels
CHAN_FD   => 0;
CHAN_BUF  => 1;
CHAN_IDX  => 2;
ICHAN_END => 3;
## Buffer sizes
IBUFFER_SIZE => 512;
OBUFFER_SIZE => 512;
## Standard channels
stdin  : NULL;
stdout : NULL;
stderr : NULL;

## Create new input channel
# a0 - fd
# @return channel
input_chan : (a0) {
	# x0 - buffer/channel
	allocate(1);
	# Allocating buffer
	x0 = malloc(IBUFFER_SIZE);
	# Creating channel
	x0 = tuple4(a0, x0, 0, 0);
	return(x0);
};

## Create new input channel based on file
# a0 - file name
# @return channel
input_chan_file : (a0) {
	# x0 - fd/channel
	allocate(1);
	# Opening file with read permission
	x0 = open(a0, O_RDONLY, 0);
	# Checking for success
	assert(x0 > 0, "Couldn't open file input channel");
	# Returning new channel
	return(input_chan(x0));
};

## Close input channel
# a0 - channel
input_chan_close : (a0) {
	# Closing fd
	close(a0[CHAN_FD]);
	# Deallocating buffer
	free(a0[CHAN_BUF]);
	# Deallocating channel
	free(a0);
};

## Create new output channel
# a0 - fd
# @return channel
output_chan : (a0) {
	# x0 - buffer/channel
	allocate(1);
	# Allocating buffer
	x0 = malloc(OBUFFER_SIZE);
	# Creating channel
	x0 = tuple3(a0, x0, 0);
	return(x0);
};

## Create new output channel based on file
# a0 - file name
# @return channel
output_chan_file : (a0) {
	# x0 - fd/channel
	allocate(1);
	# Opening file with read permission
	x0 = open(a0, O_WRONLY|O_CREAT|O_TRUNC, 420); # 420 = 0644
	# Checking for success
	assert(x0 > 0, "Couldn't open file output channel");
	# Returning new channel
	return(output_chan(x0));
};

## Close output channel
# a0 - channel
output_chan_close : (a0) {
	# Flushing buffer
	flush(a0);
	# Closing fd
	close(a0[CHAN_FD]);
	# Deallocating buffer
	free(a0[CHAN_BUF]);
	# Deallocating channel
	free(a0);
};

## Initialize standard I/O
initialize_io : () {
	stdin  = input_chan(0);  # stdin=0
	stdout = output_chan(1); # stdout=1
	stderr = output_chan(2); # stderr=2
};

## Fill input channel
# a0 - channel
fill : (a0) {
	# x0 - read count
	allocate(1);
	# Checking if buffer is exhausted
	if (a0[CHAN_IDX] == a0[ICHAN_END]) {
		# Input buffer is empty, refilling
		x0 = read(a0[CHAN_FD], a0[CHAN_BUF], IBUFFER_SIZE);
		# Resetting index and setting size
		a0[CHAN_IDX]  = 0;
		a0[ICHAN_END] = x0;
	};
};

## Read char
# a0 - channel
# @return char
fgetc : (a0) {
	# x0 - char
	allocate(1);
	# Filling buffer, if needed
	fill(a0);
	# Checking if input is ended
	if (a0[CHAN_IDX] == a0[ICHAN_END]) { return(EOF); };
	# Fetching char
	x0 = readchar(a0[CHAN_BUF], a0[CHAN_IDX]);
	# Incrementing index and returning char
	a0[CHAN_IDX] = a0[CHAN_IDX] + 1;
	return(x0);
};

## Read char from stdin
# @return char
getc : () { return(fgetc(stdin)); };

## Look ahead next char
# a0 - channel
# @return char
fnextc : (a0) {
	# Filling buffer, if needed
	fill(a0);
	# Checking if input is ended
	if (a0[CHAN_IDX] == a0[ICHAN_END]) { return(EOF); };
	# Fetching char
	return(readchar(a0[CHAN_BUF], a0[CHAN_IDX]));
};

## Look ahead next char from stdin
# @return char
nextc : () { return(fnextc(stdin)); };

## Flush output channel
# a0 - channel
flush : (a0) {
	# If buffer is not empty
	if (a0[CHAN_IDX] > 0) {
		write(a0[CHAN_FD], a0[CHAN_BUF], a0[CHAN_IDX]);
		a0[CHAN_IDX] = 0;
	};
};

## Put character
# a0 - channel
# a1 - char
fputc : (a0, a1) {
	# Writing to buffer
	writechar(a0[CHAN_BUF], a0[CHAN_IDX], a1);
	# Incrementing index
	a0[CHAN_IDX] = a0[CHAN_IDX] + 1;
	# Checking if need to flush
	if (a0[CHAN_IDX] == OBUFFER_SIZE) { flush(a0); return; };
	if (a1 == '\n') { flush(a0); return; };
};

## Put character in stdout
# a0 - char
putc  : (a0) { fputc(stdout, a0); };
## Put character in stderr
# a0 - char
eputc : (a0) { fputc(stderr, a0); };

## Put string
# a0 - channel
# a1 - string
fputs : (a0, a1) {
	# x0 - char
	allocate(1);
	# Fetching first char
	x0 = readchar(a1, 0);
	# Iterating, until we'll find '\0'
	while (x0 != '\0') {
		# Putting character
		fputc(a0, x0);
		# Reading next character
		a1 = a1 + 1;
		x0 = readchar(a1, 0);
	};
};

## Put string in stdout
# a0 - char
puts  : (a0) { fputs(stdout, a0); };
## Put string in stderr
# a0 - char
eputs : (a0) { fputs(stderr, a0); };

## Put number
# a0 - channel
# a1 - number
# a2 - base
fputn : (a0, a1, a2) {
	# x0 - number buffer
	allocate(1);
	# Allocating number buffer
	x0 = malloc(32);
	# Convering number to string
	itoa(a1, x0, a2);
	# Putting string
	fputs(a0, x0);
	# Freeing number string
	free(x0);
};

## Put decimal number in stdout
# a0 - number
putd : (a0) { fputn(stdout, a0, 10); };
## Put hexadecimal number in stdout
# a0 - number
putx : (a0) { fputn(stdout, a0, 16); };

## Assertion
# a0 - condition
# a1 - error string
assert : (a0, a1) {
	# If condition success, returning
	if (a0) { return; };
	# Printing assertion error
	eputs("ASSERT: ");
	# If error string is null, printing default message. If not, print a1
	if (a1) { eputs(a1); } else { eputs("assertion failed"); };
	eputc('\n');
	# Exitting
	exit(1);
};

### Lexer
## Character types
CHAR_NULL      => 0;  # \0 */
CHAR_INVALID   => 1;  # invalid characters */
CHAR_SPACES    => 2;  # [\t\r ]
CHAR_NEWLINE   => 3;  # \n
CHAR_ZERO      => 4;  # 0
CHAR_OCTAL     => 5;  # [1-7]
CHAR_DECIMAL   => 6;  # [89]
CHAR_HEX       => 7;  # [A-Fa-f] \ a
CHAR_ALPHA     => 8;  # [G-Zg-z_] \ x
CHAR_A         => 9;  # a
CHAR_X         => 10; # x
CHAR_SQUOTE    => 11; # \'
CHAR_DQUOTE    => 12; # \"
CHAR_BACKSLASH => 13; # \\
CHAR_SYMBOL    => 14; # other characters
## Lexer parts
LEX_ICHAN  => 0;
LEX_FILE   => 1;
LEX_LINE   => 2;
LEX_COLUMN => 3;
LEX_HOLD   => 4;
LEX_TID    => 5;
LEX_TVALUE => 6;
LEX_TTEXT  => 7;
## Token IDs
TOKEN_END     => 256;
TOKEN_INTEGER => 257;
## Char table
char_table : [
	# X0  X1  X2  X3  X4  X5  X6  X7  X8  X9  Xa  Xb  Xc  Xd  Xe  Xf
	   0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  2,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   2, 14, 12, 14, 14, 14, 14, 11, 14, 14, 14, 14, 14, 14, 14, 14,
	   4,  5,  5,  5,  5,  5,  5,  5,  6,  6, 14, 14, 14, 14, 14, 14,
	  14,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,
	   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 14, 13, 14, 14, 14,
	  14,  9,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,
	   8,  8,  8,  8,  8,  8,  8,  8, 10,  8,  8, 14, 14, 14, 14,  1,
	# We're not using Extended-ASCII - marking as invalid
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1
];
## Char to escape table (only first 128 ASCII chars)
char_to_escape : [
	# X0  X1  X2  X3  X4  X5  X6  X7  X8  X9  Xa  Xb  Xc  Xd  Xe  Xf
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0, 34,  0,  0,  0,  0, 39,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 63,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 92,  0,  0,  0,
	   0,  7,  8,  0,  0, 27, 12,  0,  0,  0,  0,  0,  0,  0, 10,  0,
	   0,  0, 13,  0,  9,  0, 11,  0,  0,  0,  0,  0,  0,  0,  0,  0
];
## Lexer triggers
lx00n:[lx01,le00,lx00,lx00,lx02,le00,le00,le00,le00,le00,le00,le00,le00,le00,le00];
lx02n:[lx99,le00,lx99,lx99,le01,lx03,le02,le03,le00,le03,lx04,le00,le00,le00,le00];
lx03n:[lx99,le00,lx99,lx99,lx03,lx03,le02,le03,le00,le03,le00,le00,le00,le00,le00];
lx04n:[le04,le00,le04,le04,lx05,lx05,lx05,lx05,le00,lx05,le00,le00,le00,le00,le00];
lx05n:[lx99,le00,lx99,lx99,lx05,lx05,lx05,lx05,le00,lx05,le00,le00,le00,le00,le00];

## Create new lexer
# a0 - input channel
# a1 - filename
# @return lexer
lexer : (a0, a1) {
	# x0 - token buffer
	# x1 - lexer
	allocate(2);
	# Creating empty token buffer
	x0 = char_vector(0, 1);
	# Pushing '\0' to token buffer
	char_vector_push(x0, '\0');
	# Allocating lexer
	x1 = tuple8(a0, a1, 1, 1, FALSE, 0, 0, x0);
	return(x1);
};

## Look ahead for next character
# a0 - lexer
# @return char type
lexer_look : (a0) {
	# x0 - char
	allocate(1);
	# Reading char
	x0 = fnextc(a0[LEX_ICHAN]);
	# If got EOF, returning CHAR_NULL
	if (x0 == EOF) { return(CHAR_NULL); };
	# Returning char type
	return(char_table[x0]);
};

## Consume char to token buffer
# a0 - lexer
# @return char
lexer_consume : (a0) {
	# x0 - char
	allocate(1);
	# Reading char
	x0 = fgetc(a0[LEX_ICHAN]);
	# If newline, moving to new line
	if (x0 == '\n') {
		a0[LEX_LINE] = a0[LEX_LINE] + 1;
		a0[LEX_COLUMN] = 0;
	};
	# Incrementing column
	a0[LEX_COLUMN] = a0[LEX_COLUMN] + 1;
	# Replacing last char (NULL) in buffer
	char_vector_set(a0[LEX_TTEXT], vector_size(a0[LEX_TTEXT]) - 1, x0);
	# Pushing NULL to the end
	char_vector_push(a0[LEX_TTEXT], '\0');
	# Returning char
	return(x0);
};

## Set token ID
# a0 - lexer
# a1 - token ID
lexer_token_set : (a0, a1) { a0[LEX_TID] = a1; };

## Get token ID
# a0 - lexer
# @return token ID
lexer_token_get : (a0) { return(a0[LEX_TID]); };

## Get token text
# a0 - lexer
# @return token text char vector
lexer_token_text : (a0) { return(a0[LEX_TTEXT]); };

## Get token value
# a0 - lexer
# @return token value
lexer_token_value : (a0) { return(a0[LEX_TVALUE]); };

## Hold token
# a0 - lexer
lexer_hold : (a0) {
	assert(a0[LEX_HOLD] == FALSE, "tried to hold two or more tokens");
	a0[LEX_HOLD] = TRUE;
};

## Reset token data
# a0 - lexer
lexer_reset_token : () {
	a0[LEX_TID] = 0;    # Resetting token id
	a0[LEX_TVALUE] = 0; # Resetting token value
	# Resetting token text buffer
	char_vector_resize(a0[LEX_TTEXT], 0);
	char_vector_push(a0[LEX_TTEXT], '\0');
};

## Print location to channel
# a0 - lexer
# a1 - channel
lexer_fputloc : (a0, a1) {
	fputs(a1, a0[LEX_FILE]);
	fputc(a1, ':');
	fputn(a1, a0[LEX_LINE], 10);
	fputc(a1, ':');
	fputn(a1, a0[LEX_COLUMN], 10);
};

## Print lexer error
# a0 - lexer
# a1 - error message
lexer_error : (a0, a1) {
	# Printing location
	lexer_fputloc(a0, stderr);
	eputs(": ");
	# Printing message
	eputs(a1);
	# Flushing
	eputc('\n');
	# Exitting
	exit(1);
};

## Fetch token
# a0 - lexer
# @return token type
lexer_lex : (a0) {
	# x0 - current char
	allocate(1);
	# Checking if we are holding token
	if (a0[LEX_HOLD]) {
		a0[LEX_HOLD] = FALSE;
		return(a0[LEX_TID]);
	};

label lx00;
	## Entry point of lexer
	# If token is space/tab/newline, skip it
	# NOTE: We're using here + instead of || as we don't have it now
	if ((lexer_look(a0) == CHAR_SPACES) + (lexer_look(a0) == CHAR_NEWLINE)) {
		# Consuming char
		lexer_consume(a0);
		# Retrying
		goto &lx00;
	};
	# Resetting token buffer
	lexer_reset_token(a0);
	# Moving to next trigger
	goto lx00n[lexer_look(a0)];
label lx01;
	## We got NULL char
	return(TOKEN_END);
label lx02;
	##  We got zero. It means we have either zero number, octal (e.g. 0664) or
	## hex number (e.g. 0xffff)
	# Consuming zero char
	lexer_consume(a0);
	# Setting integer token ID
	lexer_token_set(a0, TOKEN_INTEGER);
	# Moving to next trigger
	goto lx02n[lexer_look(a0)];
label lx03;
	## We have to parse octal number
	# Fetching digit
	x0 = lexer_consume(a0);
	# Adding digit to number
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 8 + (x0 - '0');
	# Moving to next trigger
	goto lx03n[lexer_look(a0)];
label lx04;
	## Trying to parse hexadecimal number
	# We have 'x' symbol. Consuming it
	lexer_consume(a0);
	# Moving to next trigger
	goto lx04n[lexer_look(a0)];
label lx05;
	## Parsing hexadecimal number
	# Fetching digit
	x0 = lexer_consume(a0);
	# Checking if it is lower case hexadecimal digit
	if (x0 >= 'a') {
		x0 = x0 - 'a' + 10;
	} else {
		# Checking if it is higher case hexadecimal digit
		if (x0 >= 'A') {
			x0 = x0 - 'A' + 10;
		} else {
			# It is decimal digit
			x0 = x0 - '0';
		};
	};
	# Adding digit to number
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 16 + x0;
	# Moving to next trigger
	goto lx05n[lexer_look(a0)];
label lx99;
	## Finishing lexing. Returning current token ID
	return(a0[LEX_TID]);
label le00;
	lexer_error(a0, "Invalid character");
label le01;
	lexer_error(a0, "Unexpected second 0 char");
label le02;
	lexer_error(a0, "Unexpected decimal digit (expected octal)");
label le03;
	lexer_error(a0, "Unexpected hexadecimal digit (expected octal)");
label le04;
	lexer_error(a0, "Unfinished hexadecimal number");
};

## Print usage
# a0 - program name
usage : (a0) {
	eputs("usage: ");
	eputs(a0);
	eputs(" [option]... <file>\n");
};

## Main function
# a0 - argc
# a1 - argv
# @return exit code
main : (a0, a1) {
	# x0 - input channel
	# x1 - lexer
	# x2 - token id
	allocate(3);
	# If no additional args - printing usage
	if (a0 < 2) { usage(a1[0]); return(1); };
	# TODO: implement option parser
	# Creating input channel
	x0 = input_chan_file(a1[1]);
	# Creating lexer
	x1 = lexer(x0, a1[1]);
	# Fetch first token for tests
	x2 = lexer_lex(x1);
	return(a0);
};

# Entry point of the entire program
global _start;
_start : () {
	# Initializing I/O at the start
	initialize_io();
	# argc is located in 4(%esp), argv is located in 8(%esp)
	exit(main(*(&a0 - 4), &a0));
};
