### Useful constants
NULL  => 0;
EOF   => -1;
## Booleans
FALSE => 0;
TRUE  => 1;

### System calls
SYS_exit   => 1;
SYS_read   => 3;
SYS_write  => 4;
SYS_open   => 5;
SYS_close  => 6;
SYS_brk    => 45;
SYS_munmap => 91;
SYS_mmap2  => 192;

### System call functions
## Exit with code
# a0 - exit code
exit : (a0) { syscall(SYS_exit, a0); };

## Read from file
# a0 - file
# a1 - buffer
# a2 - count
# @return read count
read : (a0, a1, a2) { return(syscall(SYS_read, a0, a1, a2)); };

## Write to file
# a0 - file
# a1 - buffer
# a2 - count
# @return write count
write : (a0, a1, a2) { return(syscall(SYS_write, a0, a1, a2)); };

## Open file
# a0 - path
# a1 - flags
# a2 - mode
# @return fd or error
open : (a0, a1, a2) { return(syscall(SYS_open, a0, a1, a2)); };

## Close file
# a0 - fd
# @return result code
close : (a0) { return(syscall(SYS_close, a0)); };

## Set/return heap segment limit
# a0 - address (set) or NULL (return)
# @return current heap limit
brk : (a0) { return(syscall(SYS_brk, a0)); };

## Unmap memory page
# a0 - address
# a1 - size
# @return zero on success, negative on error
munmap : (a0, a1) { return(syscall(SYS_munmap, a0, a1)); };

## Map memory page
# a0 - address
# a1 - size
# a2 - protection flags
# a3 - map flags
# a4 - fd
# a5 - offset
mmap2 : (a0, a1, a2, a3, a4, a5) {
	return(syscall(SYS_mmap2, a0, a1, a2, a3, a4, a5));
};

### Useful functions
## Align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align : (a0, a1) {
	return((a0 + a1 - 1) & ~(a1 - 1));
};

## Align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
	return(a0 - (a0 & (a1 - 1)));
};

### Conversions
## Int to string
# a0 - value
# a1 - result buffer
# a2 - base
itoa_digits : "0123456789abcdefghijklmnopqrstuvwxyz";
itoa : (a0, a1, a2) {
	# x0 - i
	# x1 - j
	# x2 - tmp
	allocate(3);
	x0 = 0;
	x1 = 0;

	# Writing first digit
	writechar(a1, x0, readchar(itoa_digits, a0 % a2));
	# Going to next unit
	a0 = a0 / a2;
	# Going to next char position
	x0 = x0 + 1;

	# Iterating while value is not zero
	while (a0 != 0) {
		# Writing needed char to result buffer
		writechar(a1, x0, readchar(itoa_digits, a0 % a2));
		# Going to next unit
		a0 = a0 / a2;
		# Going to next char position
		x0 = x0 + 1;
	};
	# Writing '\0' to the end of string
	writechar(a1, x0, '\0');
	# Reversing string
	while (x1 < x0) {
		# Starting from penultimate char
		x0 = x0 - 1;
		# Storing char to temp
		x2 = readchar(a1, x1);
		# Moving a1[x0] to a1[x1]
		writechar(a1, x1, readchar(a1, x0));
		# Moving temp to a1[x0]
		writechar(a1, x0, x2);
		# Reversing next chars
		x1 = x1 + 1;
	};
	# Returning result buffer
	return(a1);
};

### Memory Management
## Memory page size
PAGE_SIZE => 4096; # 0x1000
## Heap segment start and end
free_start : NULL;
free_end   : NULL;

## Allocate new memory page
allocate_new_page : () {
	# If free_end is NULL, finding brk(NULL)
	if (free_end == NULL) { free_end = brk(NULL); };
	# Moving free memory segment pointers
	free_start = free_end;
	free_end = brk(free_end + PAGE_SIZE);
};

## Allocate memory
# a0 - size
# @return allocated memory
malloc : (a0) {
	# x0 - address
	allocate(1);
	# Checking if requested size is too big
	assert(a0 <= PAGE_SIZE, "Requested memory is bigger than PAGE_SIZE");
	# Checking if we need to allocate more memory
	if (free_start + a0 > free_end) { allocate_new_page(); };
	# Setting address
	x0 = free_start;
	# Moving free segment pointer
	free_start = align(x0 + a0, 16);
	# Returning memory address
	return(x0);
};

## Free memory
# a0 - address
# NOTE: in this implementation of memory allocator it is impossible
free : (a0) {};

## Allocate cleared memory
# a0 - size
# @return allocated and cleared memory
calloc : (a0) {
	# x0 - address
	allocate(1);
	# Allocating memory
	x0 = malloc(a0);
	# Clearing memory with zeroes
	memset(0, x0, a0);
	return(x0);
};

## Reallocate memory with new size
# a0 - allocated memory
# a1 - old size
# a2 - new size
# @return new allocated memory
realloc : (a0, a1, a2) {
	# x0 - old size/min size
	# x1 - new allocated memory space
	allocate(2);
	# Finding out the amount of memory to be copied
	x0 = a1;
	if (a2 < a1) { x0 = a2; };
	# Allocating new memory
	x1 = calloc(a2);
	# Copying data to new memory space
	memcpy(a0, x1, x0);
	# Freeing old memory space
	free(a0);
	return(x1);
};

### Memory/String operations
## Fill memory block with value (char)
# a0 - value
# a1 - address
# a2 - size
memset : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	# Writing value to memory block
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, a0);
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Copy data from one memory block to another
# a0 - src
# a1 - dest
# a2 - size
memcpy : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, readchar(a0, x0));
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Get length of string
# a0 - string
# @return string length
strlen : (a0) {
	# x0 - string length
	allocate(1);
	x0 = 0;
	# While char is not NULL, incrementing length
	while (readchar(a0, x0) != '\0') { x0 = x0 + 1; };
	return(x0);
};

## Copy string
# a0 - src
# a1 - dest
strcpy : (a0, a1) {
	# x0 - pos
	# x1 - char
	allocate(2);
	x0 = 0;
	# Reading char from string
	x1 = readchar(a0, x0);
	# Checking if char is not NULL
	while (x1 != '\0') {
		# Copying char from one string to another
		writechar(a1, x0, x1);
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
	};
	# Writing NULL character
	writechar(a1, x0, '\0');
};

## Compare string
# a0 - first string
# a1 - second string
# @return difference between different chars (0 if strings are equal)
strcmp : (a0, a1) {
	# x0 - pos
	# x1 - char from first string
	# x2 - char from second string
	allocate(3);
	x0 = 0;
	# Reading first chars from strings
	x1 = readchar(a0, x0);
	x2 = readchar(a1, x0);
	# Comparing char by char
	while (x1 != '\0') {
		if (x1 != x2) { return(x1 - x2); };
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
		x2 = readchar(a1, x0);
	};
	# As first string ended, finding the difference between ending chars
	return(x1 - x2);
};

## Duplicate string
# a0 - string
# @return new string
strdup : (a0) {
	# x0 - string length
	# x1 - new string
	allocate(2);
	# Allocating new string
	x0 = strlen(a0);
	x1 = calloc(x0 + 1);
	# Copying data to new string
	memcpy(a0, x1, x0);
	# Return new string
	return(x1);
};

## Duplicate string literal (without double quotes)
# a0 - string
# @return new string
strlitdup : (a0) {
	# x0 - string length
	# x1 - new string
	allocate(2);
	# Calculating length
	x0 = strlen(a0) - 2;
	# Allocating string
	x1 = calloc(x0 + 1);
	# Copying data to new string
	memcpy(a0 + 1, x1, x0);
	# Return new string
	return(x1);
};

### Tuples
## Allocate tuple
# a0 - size
# @return allocated tuple
allocate_tuple : (a0) { return malloc(4 * a0); };

## Make tuple with 1 value
# a0 - value
# @return tuple
tuple1 : (a0) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(1);
	# Fill tuple
	x0[0] = a0;
	return(x0);
};

## Make tuple with 2 values
# a0, a1 - values
# @return tuple
tuple2 : (a0, a1) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(2);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	return(x0);
};

## Make tuple with 3 values
# a0, a1, a2 - values
# @return tuple
tuple3 : (a0, a1, a2) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(3);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	return(x0);
};

## Make tuple with 4 values
# a0, a1, a2, a3 - values
# @return tuple
tuple4 : (a0, a1, a2, a3) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(4);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	return(x0);
};

## Make tuple with 5 values
# a0, a1, a2, a3, a4 - values
# @return tuple
tuple5 : (a0, a1, a2, a3, a4) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(5);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	return(x0);
};

## Make tuple with 7 values
# a0, a1, a2, a3, a4, a5, a6 - values
# @return tuple
tuple7 : (a0, a1, a2, a3, a4, a5, a6) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(7);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	x0[5] = a5;
	x0[6] = a6;
	return(x0);
};

## Make tuple with 8 values
# a0, a1, a2, a3, a4, a5, a6, a7 - values
# @return tuple
tuple8 : (a0, a1, a2, a3, a4, a5, a6, a7) {
	# x0 - tuple
	allocate(1);
	x0 = allocate_tuple(7);
	# Fill tuple
	x0[0] = a0;
	x0[1] = a1;
	x0[2] = a2;
	x0[3] = a3;
	x0[4] = a4;
	x0[5] = a5;
	x0[6] = a6;
	x0[7] = a7;
	return(x0);
};

### Linked List
## List parts
LIST_NEXT  => 0;
LIST_VALUE => 1;

## Create linked list with value
# a0 - value
# @return list
list : (a0) { return(list_insert(NULL, a0)); };

## Insert value in linked list
# a0 - list
# a1 - value
# @return list with new value
list_insert : (a0, a1) { return(tuple2(a0, a1)); };

## Get next element of linked list
# a0 - list
# @return list with next value
list_next : (a0) { return(a0[LIST_NEXT]); };

## Get value of current element of linked list
# a0 - list
# @return current element value
list_value : (a0) { return(a0[LIST_VALUE]); };

## Remove this element from list
# a0 - list
# @return reduced list
list_pop : (a0) {
	# x0 - list continuation
	allocate(1);
	# Fetching next element
	x0 = list_next(a0);
	# Deallocating current element
	free(a0);
	return(x0);
};

### Vector
## Vector parts
VEC_SIZE => 0;
VEC_CAP  => 1;
VEC_BUF  => 2;

## Create character vector
# a0 - size
# a1 - capacity
# @return character vector
char_vector : (a0, a1) { return(tuple3(a0, a1, calloc(a1))); };

## Create vector
# a0 - size
# a1 - capacity
# @return vector
vector : (a0, a1) { return(tuple3(a0, a1, calloc(4 * a1))); };

## Get vector buffer
# a0 - vector
# @return vector buffer
vector_buffer : (a0) { return(a0[VEC_BUF]); };

## Get vector size
# a0 - vector
# @return vector size
vector_size : (a0) { return(a0[VEC_SIZE]); };

## Reserve more space for char vector buffer
# a0 - char vector
# a1 - new capacity
char_vector_reserve : (a0, a1) {
	# Reserving, if new capacity is bigger
	if (a1 > a0[VEC_CAP]) {
		# Reallocating buffer
		a0[VEC_BUF] = realloc(a0[VEC_BUF], a0[VEC_CAP], a1);
		# Setting new capacity
		a0[VEC_CAP] = a1;
	};
};

## Reserve more space for vector buffer
# a0 - vector
# a1 - new capacity
vector_reserve : (a0, a1) {
	# Reserving, if new capacity is bigger
	if (a1 > a0[VEC_CAP]) {
		# Reallocating buffer
		a0[VEC_BUF] = realloc(a0[VEC_BUF], 4 * a0[VEC_CAP], 4 * a1);
		# Setting new capacity
		a0[VEC_CAP] = a1;
	};
};

## Resize char vector
# a0 - char vector
# a1 - new size
char_vector_resize : (a0, a1) {
	# Reserving, if required
	if (a1 > a0[VEC_SIZE]) { char_vector_reserve(a0, a1); };
	# Setting new size
	a0[VEC_SIZE] = a1;
};

## Resize vector
# a0 - vector
# a1 - new size
vector_resize : (a0, a1) {
	# Reserving, if required
	if (a1 > a0[VEC_SIZE]) { vector_reserve(a0, a1); };
	# Setting new size
	a0[VEC_SIZE] = a1;
};

## Get value at index in char vector
# a0 - char vector
# a1 - index
# @return char
char_vector_get : (a0, a1) { return(readchar(a0[VEC_BUF], a1)); };

## Get value at index in vector
# a0 - vector
# a1 - index
# @return value
vector_get : (a0, a1) { return(a0[VEC_BUF][a1]); };

## Set value at index in char vector
# a0 - char vector
# a1 - index
# a2 - char
char_vector_set : (a0, a1, a2) { writechar(a0[VEC_BUF], a1, a2); };

## Set value at index in vector
# a0 - vector
# a1 - index
# a2 - value
vector_set : (a0, a1, a2) {
	# x0 - buffer
	allocate(1);
	x0 = a0[VEC_BUF];
	x0[a1] = a2;
};

## Insert value in the end of char vector
# a0 - char vector
# a1 - value
char_vector_push : (a0, a1) {
	# If vector buffer is full, reserving more
	if (a0[VEC_SIZE] == a0[VEC_CAP]) {
		char_vector_reserve(a0, a0[VEC_CAP] * 2);
	};
	# Putting new value
	char_vector_set(a0, a0[VEC_SIZE], a1);
	# Incrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] + 1;
};

## Insert value in the end of vector
# a0 - vector
# a1 - value
vector_push : (a0, a1) {
	# If vector buffer is full, reserving more
	if (a0[VEC_SIZE] == a0[VEC_CAP]) {
		vector_reserve(a0, a0[VEC_CAP] * 2);
	};
	# Putting new value
	vector_set(a0, a0[VEC_SIZE], a1);
	# Incrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] + 1;
};

## Remove and return last value from char vector
# a0 - char vector
# @return char
char_vector_pop : (a0) {
	# Decrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] - 1;
	# Returning the value
	return(char_vector_get(a0, a0[VEC_SIZE]));
};

## Remove and return last value from vector
# a0 - vector
# @return value
vector_pop : (a0) {
	# Decrementing size
	a0[VEC_SIZE] = a0[VEC_SIZE] - 1;
	# Returning the value
	return(vector_get(a0, a0[VEC_SIZE]));
};

## Destroy vector
# a0 - vector
vector_destroy : (a0) {
	# Deallocating buffer
	free(a0[VEC_BUF]);
	# Deallocating vector
	free(a0);
};

### I/O
## Open flags
O_RDONLY => 0;
O_WRONLY => 1;
O_RDWR   => 2;
O_CREAT  => 64;
O_TRUNC  => 512;
O_APPEND => 1024;
## Parts of I/O channels
CHAN_FD   => 0;
CHAN_BUF  => 1;
CHAN_IDX  => 2;
ICHAN_END => 3;
ICHAN_EOF => 4;
## Buffer sizes
IBUFFER_SIZE => 512;
OBUFFER_SIZE => 512;
## Standard channels
stdin  : NULL;
stdout : NULL;
stderr : NULL;

## Create new input channel
# a0 - fd
# @return channel
input_chan : (a0) {
	# x0 - buffer/channel
	allocate(1);
	# Allocating buffer
	x0 = malloc(IBUFFER_SIZE);
	# Creating channel
	x0 = tuple5(a0, x0, 0, 0, FALSE);
	return(x0);
};

## Create new input channel based on file
# a0 - file name
# @return channel
input_chan_file : (a0) {
	# x0 - fd/channel
	allocate(1);
	# Opening file with read permission
	x0 = open(a0, O_RDONLY, 0);
	# Checking for success
	assert(x0 > 0, "Couldn't open file input channel");
	# Returning new channel
	return(input_chan(x0));
};

## Close input channel
# a0 - channel
input_chan_close : (a0) {
	# Closing fd
	close(a0[CHAN_FD]);
	# Deallocating buffer
	free(a0[CHAN_BUF]);
	# Deallocating channel
	free(a0);
};

## Create new output channel
# a0 - fd
# @return channel
output_chan : (a0) {
	# x0 - buffer/channel
	allocate(1);
	# Allocating buffer
	x0 = malloc(OBUFFER_SIZE);
	# Creating channel
	x0 = tuple3(a0, x0, 0);
	return(x0);
};

## Create new output channel based on file
# a0 - file name
# @return channel
output_chan_file : (a0) {
	# x0 - fd/channel
	allocate(1);
	# Opening file with read permission
	x0 = open(a0, O_WRONLY|O_CREAT|O_TRUNC, 420); # 420 = 0644
	# Checking for success
	assert(x0 > 0, "Couldn't open file output channel");
	# Returning new channel
	return(output_chan(x0));
};

## Close output channel
# a0 - channel
output_chan_close : (a0) {
	# Flushing buffer
	flush(a0);
	# Closing fd
	close(a0[CHAN_FD]);
	# Deallocating buffer
	free(a0[CHAN_BUF]);
	# Deallocating channel
	free(a0);
};

## Initialize standard I/O
initialize_io : () {
	stdin  = input_chan(0);  # stdin=0
	stdout = output_chan(1); # stdout=1
	stderr = output_chan(2); # stderr=2
};

## Fill input channel
# a0 - channel
fill : (a0) {
	# x0 - read count
	allocate(1);
	# Checking if file is ended
	if (a0[ICHAN_EOF]) { return; };
	# Checking if buffer is exhausted
	if (a0[CHAN_IDX] == a0[ICHAN_END]) {
		# Input buffer is empty, refilling
		x0 = read(a0[CHAN_FD], a0[CHAN_BUF], IBUFFER_SIZE);
		# Resetting index and setting size
		a0[CHAN_IDX]  = 0;
		a0[ICHAN_END] = x0;
		# Setting EOF flag, if file is ended
		if (a0[ICHAN_END] == 0) { a0[ICHAN_EOF] = TRUE; };
	};
};

## Read char
# a0 - channel
# @return char
fgetc : (a0) {
	# x0 - char
	allocate(1);
	# Filling buffer, if needed
	fill(a0);
	# Checking if input is ended
	if (a0[CHAN_IDX] == a0[ICHAN_END]) { return(EOF); };
	# Fetching char
	x0 = readchar(a0[CHAN_BUF], a0[CHAN_IDX]);
	# Incrementing index and returning char
	a0[CHAN_IDX] = a0[CHAN_IDX] + 1;
	return(x0);
};

## Read char from stdin
# @return char
getc : () { return(fgetc(stdin)); };

## Look ahead next char
# a0 - channel
# @return char
fnextc : (a0) {
	# Filling buffer, if needed
	fill(a0);
	# Checking if input is ended
	if (a0[CHAN_IDX] == a0[ICHAN_END]) { return(EOF); };
	# Fetching char
	return(readchar(a0[CHAN_BUF], a0[CHAN_IDX]));
};

## Look ahead next char from stdin
# @return char
nextc : () { return(fnextc(stdin)); };

## Flush output channel
# a0 - channel
flush : (a0) {
	# If buffer is not empty
	if (a0[CHAN_IDX] > 0) {
		write(a0[CHAN_FD], a0[CHAN_BUF], a0[CHAN_IDX]);
		a0[CHAN_IDX] = 0;
	};
};

## Put character
# a0 - channel
# a1 - char
fputc : (a0, a1) {
	# Writing to buffer
	writechar(a0[CHAN_BUF], a0[CHAN_IDX], a1);
	# Incrementing index
	a0[CHAN_IDX] = a0[CHAN_IDX] + 1;
	# Checking if need to flush
	if (a0[CHAN_IDX] == OBUFFER_SIZE) { flush(a0); return; };
	if (a1 == '\n') { flush(a0); return; };
};

## Put character in stdout
# a0 - char
putc  : (a0) { fputc(stdout, a0); };
## Put character in stderr
# a0 - char
eputc : (a0) { fputc(stderr, a0); };

## Put string
# a0 - channel
# a1 - string
fputs : (a0, a1) {
	# x0 - char
	allocate(1);
	# Fetching first char
	x0 = readchar(a1, 0);
	# Iterating, until we'll find '\0'
	while (x0 != '\0') {
		# Putting character
		fputc(a0, x0);
		# Reading next character
		a1 = a1 + 1;
		x0 = readchar(a1, 0);
	};
};

## Put string in stdout
# a0 - char
puts  : (a0) { fputs(stdout, a0); };
## Put string in stderr
# a0 - char
eputs : (a0) { fputs(stderr, a0); };

## Put number
# a0 - channel
# a1 - number
# a2 - base
fputn_buffer : NULL;
fputn : (a0, a1, a2) {
	# Allocating number buffer, if needed
	if (fputn_buffer == NULL) { fputn_buffer = malloc(33); };
	# Clearing buffer
	memset(0, fputn_buffer, 33);
	# Convering number to string
	itoa(a1, fputn_buffer, a2);
	# Putting string
	fputs(a0, fputn_buffer);
};

## Put decimal number in stdout
# a0 - number
putd  : (a0) { fputn(stdout, a0, 10); };
## Put hexadecimal number in stdout
# a0 - number
putx  : (a0) { fputn(stdout, a0, 16); };
## Put decimal number in stderr
# a0 - number
eputd : (a0) { fputn(stderr, a0, 10); };
## Put hexadecimal number in stderr
# a0 - number
eputx : (a0) { fputn(stderr, a0, 16); };

## Assertion
# a0 - condition
# a1 - error string
assert : (a0, a1) {
	# If condition success, returning
	if (a0) { return; };
	# Printing assertion error
	eputs("ASSERT: ");
	# If error string is null, printing default message. If not, print a1
	if (a1) { eputs(a1); } else { eputs("assertion failed"); };
	eputc('\n');
	# Exitting
	exit(1);
};

### Lexer
## Character types
CHAR_NULL      => 0;  # \0 */
CHAR_INVALID   => 1;  # invalid characters */
CHAR_SPACES    => 2;  # [\t\r ]
CHAR_NEWLINE   => 3;  # \n
CHAR_ZERO      => 4;  # 0
CHAR_OCTAL     => 5;  # [1-7]
CHAR_DECIMAL   => 6;  # [89]
CHAR_HEX       => 7;  # [A-Fa-f] \ a
CHAR_ALPHA     => 8;  # [G-Zg-z_] \ x
CHAR_A         => 9;  # a
CHAR_X         => 10; # x
CHAR_SQUOTE    => 11; # \'
CHAR_DQUOTE    => 12; # \"
CHAR_BACKSLASH => 13; # \\
CHAR_SYMBOL    => 14; # other characters
## Lexer parts
LEX_ICHAN  => 0;
LEX_FILE   => 1;
LEX_LINE   => 2;
LEX_COLUMN => 3;
LEX_HOLD   => 4;
LEX_TID    => 5;
LEX_TVALUE => 6;
LEX_TTEXT  => 7;
### Token IDs
TOKEN_END        => 256;
TOKEN_INTEGER    => 257;
TOKEN_IDENTIFIER => 258;
TOKEN_STRING     => 259;
TOKEN_ARGUMENT   => 260;
TOKEN_VARIABLE   => 261;
## Keywords
# Conditionals
TOKEN_IF         => 270;
TOKEN_ELSE       => 271;
# Loops
TOKEN_BREAK      => 272;
TOKEN_WHILE      => 273;
# Functions
TOKEN_ALLOCATE   => 274;
TOKEN_RETURN     => 275;
TOKEN_SYSCALL    => 276;
# Labels
TOKEN_GLOBAL     => 277;
TOKEN_GOTO       => 278;
TOKEN_LABEL      => 279;
# Byte operations
TOKEN_READCHAR   => 280;
TOKEN_WRITECHAR  => 281;
# Array types
TOKEN_TYPE_CHAR  => 282;
TOKEN_TYPE_INT   => 283;
# File
TOKEN_INCLUDE    => 284;
## Symbols
# Equality
TOKEN_EQ => 300;
TOKEN_NE => 301;
# Compare
TOKEN_LE => 302;
TOKEN_GE => 303;
# Arrow
TOKEN_AR => 304;
## Char table
char_table : [
	# X0  X1  X2  X3  X4  X5  X6  X7  X8  X9  Xa  Xb  Xc  Xd  Xe  Xf
	   0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  2,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   2, 14, 12, 14, 14, 14, 14, 11, 14, 14, 14, 14, 14, 14, 14, 14,
	   4,  5,  5,  5,  5,  5,  5,  5,  6,  6, 14, 14, 14, 14, 14, 14,
	  14,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,
	   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 14, 13, 14, 14,  7,
	  14,  9,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,
	   8,  8,  8,  8,  8,  8,  8,  8, 10,  8,  8, 14, 14, 14, 14,  1,
	# We're not using Extended-ASCII - marking as invalid
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1
];
## Char to escape table (only first 128 ASCII chars)
char_to_escape : [
	# X0  X1  X2  X3  X4  X5  X6  X7  X8  X9  Xa  Xb  Xc  Xd  Xe  Xf
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0, 34,  0,  0,  0,  0, 39,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 63,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 92,  0,  0,  0,
	   0,  7,  8,  0,  0, 27, 12,  0,  0,  0,  0,  0,  0,  0, 10,  0,
	   0,  0, 13,  0,  9,  0, 11,  0,  0,  0,  0,  0,  0,  0,  0,  0
];
## Reserved keywords
reserved_keywords : [
	"if", "else",                    # Conditionals
	"break", "while",                # Loops
	"allocate", "return", "syscall", # Functions
	"global", "goto", "label",       # Labels
	"readchar", "writechar",         # Byte operations
	"char", "int",                   # Array types
	"include",
	NULL
];
## Lexer triggers
lx00n:[lx01,le00,lx00,lx00,lx02,lx06,lx06,lx07,lx07,lx09,lx09,lx11,lx15,le00,lx17];
lx02n:[lx99,le00,lx99,lx99,le01,lx03,le02,le03,le00,le03,lx04,le00,le00,le00,lx99];
lx03n:[lx99,le00,lx99,lx99,lx03,lx03,le02,le03,le00,le03,le00,le00,le00,le00,lx99];
lx04n:[le04,le00,le04,le04,lx05,lx05,lx05,lx05,le00,lx05,le00,le00,le00,le00,le00];
lx05n:[lx99,le00,lx99,lx99,lx05,lx05,lx05,lx05,le00,lx05,le00,le00,le00,le00,lx99];
lx06n:[lx99,le00,lx99,lx99,lx06,lx06,lx06,le05,le00,le05,le00,le00,le00,le00,lx99];
lx07n:[lx08,le00,lx08,lx08,lx07,lx07,lx07,lx07,lx07,lx07,lx07,le00,le00,le00,lx08];
lx09n:[lx08,le00,lx08,lx08,lx10,lx10,lx10,lx07,lx07,lx07,lx07,le00,le00,le00,lx08];
lx10n:[lx99,le00,lx99,lx99,lx10,lx10,lx10,lx07,lx07,lx07,lx07,le00,le00,le00,lx99];
lx11n:[le06,le00,lx12,le06,lx12,lx12,lx12,lx12,lx12,lx12,lx12,lx12,lx12,lx13,lx12];
lx15n:[le07,le00,lx15,le07,lx15,lx15,lx15,lx15,lx15,lx15,lx15,lx15,lx16,lx15,lx15];

## Create new lexer
# a0 - input channel
# a1 - filename
# @return lexer
lexer : (a0, a1) {
	# x0 - token buffer
	# x1 - lexer
	allocate(2);
	# Creating empty token buffer
	x0 = char_vector(0, 1);
	# Pushing '\0' to token buffer
	char_vector_push(x0, '\0');
	# Allocating lexer
	x1 = tuple8(a0, a1, 1, 1, FALSE, 0, 0, x0);
	return(x1);
};

## Create new lexer using file name
# a0 - filename
# @return lexer
lexer_file : (a0) { return(lexer(input_chan_file(a0), a0)); };

## Destroy lexer
# a0 - lexer
lexer_destroy : (a0) {
	# Destroying token char vector
	vector_destroy(a0[LEX_TTEXT]);
	# Destroying input channel
	input_chan_close(a0[LEX_ICHAN]);
	# Freeing filename string
	free(a0[LEX_FILE]);
	# Destroying lexer
	free(a0);
};

## Look ahead for next character
# a0 - lexer
# @return char type
lexer_look : (a0) {
	# x0 - char
	allocate(1);
	# Reading char
	x0 = fnextc(a0[LEX_ICHAN]);
	# If got EOF, returning CHAR_NULL
	if (x0 == EOF) { return(CHAR_NULL); };
	# Returning char type
	return(char_table[x0]);
};

## Consume char to token buffer
# a0 - lexer
# @return char
lexer_consume : (a0) {
	# x0 - char
	allocate(1);
	# Reading char
	x0 = fgetc(a0[LEX_ICHAN]);
	# If newline, moving to new line
	if (x0 == '\n') {
		a0[LEX_LINE] = a0[LEX_LINE] + 1;
		a0[LEX_COLUMN] = 0;
	};
	# Incrementing column
	a0[LEX_COLUMN] = a0[LEX_COLUMN] + 1;
	# Replacing last char (NULL) in buffer
	char_vector_set(a0[LEX_TTEXT], lexer_token_length(a0) - 1, x0);
	# Pushing NULL to the end
	char_vector_push(a0[LEX_TTEXT], '\0');
	# Returning char
	return(x0);
};

## Set token ID
# a0 - lexer
# a1 - token ID
lexer_token_set : (a0, a1) { a0[LEX_TID] = a1; };

## Get token ID
# a0 - lexer
# @return token ID
lexer_token_get : (a0) { return(a0[LEX_TID]); };

## Get token text
# a0 - lexer
# @return token text char vector
lexer_token_text : (a0) { return(vector_buffer(a0[LEX_TTEXT])); };

## Get token text length
# a0 - lexer
# @return token text length
lexer_token_length : (a0) { return(vector_size(a0[LEX_TTEXT])); };

## Get token value
# a0 - lexer
# @return token value
lexer_token_value : (a0) { return(a0[LEX_TVALUE]); };

## Hold token
# a0 - lexer
lexer_hold : (a0) {
	assert(a0[LEX_HOLD] == FALSE, "tried to hold two or more tokens");
	a0[LEX_HOLD] = TRUE;
};

## Reset token data
# a0 - lexer
lexer_reset_token : (a0) {
	a0[LEX_TID] = 0;    # Resetting token id
	a0[LEX_TVALUE] = 0; # Resetting token value
	# Resetting token text buffer
	char_vector_resize(a0[LEX_TTEXT], 0);
	char_vector_push(a0[LEX_TTEXT], '\0');
};

## Print location to channel
# a0 - lexer
# a1 - channel
lexer_fputloc : (a0, a1) {
	fputs(a1, a0[LEX_FILE]);
	fputc(a1, ':');
	fputn(a1, a0[LEX_LINE], 10);
	fputc(a1, ':');
	fputn(a1, a0[LEX_COLUMN] - lexer_token_length(a0) + 1, 10);
};

## Print lexer error
# a0 - lexer
# a1 - error message
lexer_error : (a0, a1) {
	# Printing location
	lexer_fputloc(a0, stderr);
	eputs(": ");
	# Printing message
	eputs(a1);
	# Flushing
	eputc('\n');
	# Exitting
	exit(1);
};

## Fetch token
# a0 - lexer
# @return token type
lexer_lex : (a0) {
	# x0 - current char
	# x1 - reserved keyword index
	allocate(2);
	# Checking if we are holding token
	if (a0[LEX_HOLD]) {
		a0[LEX_HOLD] = FALSE;
		return(a0[LEX_TID]);
	};

label lx00;
	## Entry point of lexer
	# If token is space/tab/newline, skip it
	# NOTE: We're using here + instead of || as we don't have it now
	if ((lexer_look(a0) == CHAR_SPACES) + (lexer_look(a0) == CHAR_NEWLINE)) {
		# Consuming char
		lexer_consume(a0);
		# Retrying
		goto &lx00;
	};
	# Resetting token buffer
	lexer_reset_token(a0);
	# Moving to next trigger
	goto lx00n[lexer_look(a0)];
label lx01;
	## We got NULL char
	return(TOKEN_END);
label lx02;
	##  We got zero. It means we have either zero number, octal (e.g. 0664) or
	## hex number (e.g. 0xffff)
	# Consuming zero char
	lexer_consume(a0);
	# Setting integer token ID
	lexer_token_set(a0, TOKEN_INTEGER);
	# Moving to next trigger
	goto lx02n[lexer_look(a0)];
label lx03;
	## We have to parse octal number
	# Fetching digit
	x0 = lexer_consume(a0);
	# Adding digit to number
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 8 + (x0 - '0');
	# Moving to next trigger
	goto lx03n[lexer_look(a0)];
label lx04;
	## Trying to parse hexadecimal number
	# We have 'x' symbol. Consuming it
	lexer_consume(a0);
	# Moving to next trigger
	goto lx04n[lexer_look(a0)];
label lx05;
	## Parsing hexadecimal number
	# Fetching digit
	x0 = lexer_consume(a0);
	# Checking if it is lower case hexadecimal digit
	if (x0 >= 'a') {
		x0 = x0 - 'a' + 10;
	} else {
		# Checking if it is higher case hexadecimal digit
		if (x0 >= 'A') {
			x0 = x0 - 'A' + 10;
		} else {
			# It is decimal digit
			x0 = x0 - '0';
		};
	};
	# Adding digit to number
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 16 + x0;
	# Moving to next trigger
	goto lx05n[lexer_look(a0)];
label lx06;
	## We have to parse decimal number
	# We have to set integer token ID
	lexer_token_set(a0, TOKEN_INTEGER);
	# Fetching digit
	x0 = lexer_consume(a0);
	# Adding digit to number
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 10 + (x0 - '0');
	# Moving to next trigger
	goto lx06n[lexer_look(a0)];
label lx07;
	## We have to parse identifier
	# We have to set identifier token ID
	lexer_token_set(a0, TOKEN_IDENTIFIER);
	# Adding char to token text
	lexer_consume(a0);
	# Moving to next trigger
	goto lx07n[lexer_look(a0)];
label lx08;
	## Checking if identifier is keyword
	# Resetting reserved keyword index
	x1 = 0;
	# Iterating through all reserved keywords
	while (reserved_keywords[x1] != NULL) {
		# If strings are equal
		if (strcmp(reserved_keywords[x1], lexer_token_text(a0)) == NULL) {
			# Setting keyword token ID
			lexer_token_set(a0, TOKEN_IF + x1);
			goto &lx99;
		};
		# Checking next keyword
		x1 = x1 + 1;
	};
	# We are here because identifier is not a keyword. Exitting
	goto &lx99;
label lx09;
	## We have to parse argument or variable (or identifier)
	# Fetching char
	x0 = lexer_consume(a0);
	# Checking if we have argument or variable
	x1 = TOKEN_VARIABLE;
	if (x0 == 'a') { x1 = TOKEN_ARGUMENT; };
	# Set token type
	lexer_token_set(a0, x1);
	# Moving to next trigger
	goto lx09n[lexer_look(a0)];
label lx10;
	## Parsing number of argument/variable
	# Fetching char
	x0 = lexer_consume(a0);
	# Adding digit to value
	a0[LEX_TVALUE] = a0[LEX_TVALUE] * 10 + (x0 - '0');
	# Moving to next trigger
	goto lx10n[lexer_look(a0)];
label lx11;
	## Parsing single quote (character literal)
	# Setting integer token ID
	lexer_token_set(a0, TOKEN_INTEGER);
	# Consuming char
	lexer_consume(a0);
	# Moving to next trigger
	goto lx11n[lexer_look(a0)];
label lx12;
	## Parsing single quote 'simple' content (without backslash)
	# Fetching char
	x0 = lexer_consume(a0);
	# Setting value
	a0[LEX_TVALUE] = x0;
	goto &lx14;
label lx13;
	## Parsing single quote content with backslash
	# Consuming backslash
	lexer_consume(a0);
	# Fetching char
	x0 = lexer_consume(a0);
	# Setting escape value
	a0[LEX_TVALUE] = char_to_escape[x0];
label lx14;
	# Checking if quotes are closed
	if (lexer_look(a0) != CHAR_SQUOTE) { goto &le06; };
	# Consuming char
	lexer_consume(a0);
	goto &lx99;
label lx15;
	## Parsing double quote (string literal)
	# Consuming char
	lexer_consume(a0);
	# Moving to next trigger
	goto lx15n[lexer_look(a0)];
label lx16;
	## Ending string
	# Consuming char
	lexer_consume(a0);
	# Setting string token ID
	lexer_token_set(a0, TOKEN_STRING);
	# Ending
	goto &lx99;
label lx17;
	## Parsing symbol
	# Fetching char
	x0 = lexer_consume(a0);
	# Setting token ID to char value
	lexer_token_set(a0, x0);
	# Fetching next char
	x1 = fnextc(a0[LEX_ICHAN]);
	# Checking for double-char symbols
	if (x0 == '=') {
		if (x1 == '=') { lexer_consume(a0); lexer_token_set(a0, TOKEN_EQ); };
		if (x1 == '>') { lexer_consume(a0); lexer_token_set(a0, TOKEN_AR); };
	};

	if (x0 == '!') {
		if (x1 == '=') { lexer_consume(a0); lexer_token_set(a0, TOKEN_NE); };
	};

	if (x0 == '<') {
		if (x1 == '=') { lexer_consume(a0); lexer_token_set(a0, TOKEN_LE); };
	};

	if (x0 == '>') {
		if (x1 == '=') { lexer_consume(a0); lexer_token_set(a0, TOKEN_GE); };
	};

	# Checking for comment
	if (x0 == '#') {
		## Skipping line
		# NOTE: using * insead of &&, because we don't have it
		while ((x0 != '\n') * (x0 != '\0')) { x0 = fgetc(a0[LEX_ICHAN]); };
		# Resetting line and column
		a0[LEX_LINE] = a0[LEX_LINE] + 1;
		a0[LEX_COLUMN] = 1;
		# Starting lexing from the start
		goto &lx00;
	};
label lx99;
	## Finishing lexing. Returning current token ID
	return(a0[LEX_TID]);
label le00;
	lexer_error(a0, "Invalid character");
label le01;
	lexer_error(a0, "Unexpected second 0 char");
label le02;
	lexer_error(a0, "Unexpected decimal digit (expected octal)");
label le03;
	lexer_error(a0, "Unexpected hexadecimal digit (expected octal)");
label le04;
	lexer_error(a0, "Unfinished hexadecimal number");
label le05;
	lexer_error(a0, "Unexpected hexadecimal digit (expected decimal)");
label le06;
	lexer_error(a0, "Unterminated character literal");
label le07;
	lexer_error(a0, "Unterminated string literal");
};

### Parser
## Parser parts
PARSER_LEX    => 0;
PARSER_SWITCH => 1;
## Node parts
NODE_TYPE => 0;
NODE_OP1  => 1;
NODE_OP2  => 2;
## Statement IDs
STATEMENT_GLOBAL => 0;

## Create new parser
# a0 - lexer of main file
# @return parser
parser : (a0) { return(tuple2(list(a0), FALSE)); };

## Get current lexer in parser
# a0 - parser
# @return lexer
parser_lexer : (a0) { return(list_value(a0[PARSER_LEX])); };

## Lex using current lexer in parser
# a0 - parser
# @return token ID
parser_lex : (a0) { return(lexer_lex(parser_lexer(a0))); };

## Print parser error
# a0 - parser
# a1 - error message
parser_error : (a0, a1) { lexer_error(parser_lexer(a0), a1); };

## Parse file
# a0 - parser
# @return AST
parser_parse : (a0) {
	# x0 - top level statements vector
	# x1 - token
	# x2 - statement
	allocate(3);
	# Allocating statements vector
	x0 = vector(0, 1);
label parser_parse_continue;
	## Parsing file
	# Fetching token for tests
	x1 = parser_lex(a0);
	# Testing until got end of file
	while (x1 != TOKEN_END) {
		# If token is ;, skipping it as empty statement
		if (x1 == ';') { goto &parser_parse_continue; };
		# Parsing statement
		x2 = top_level_statement(a0, x1);
		# Adding statement, if needed
		if (x2) { vector_push(x0, x2); };
		# Fetching next token
		x1 = parser_lex(a0);
		# Checking statement to be ended with ;
		if (x1 != ';') {
			# Checking if we switched to new file before
			if (a0[PARSER_SWITCH] == FALSE) {
				goto &parser_parse_error;
			};
			# Disabling this flag
			a0[PARSER_SWITCH] = FALSE;
			# Holding token
			lexer_hold(parser_lexer(a0));
		};
		# Fetching next token
		x1 = parser_lex(a0);
	};
	# Destroying lexer
	lexer_destroy(parser_lexer(a0));
	# Switching to previous lexer
	a0[PARSER_LEX] = list_next(a0[PARSER_LEX]);
	# If lexer is not NULL, continuing
	if (a0[PARSER_LEX] != NULL) { goto &parser_parse_continue; };
	# Returning statemtents vector
	return(x0);
label parser_parse_error;
	parser_error(a0, "Statement is not ended with semicolon");
};

## Parse top level statement
# a0 - parser
# a1 - current token
# @return statement
top_level_statement : (a0, a1) {
	# x0 - next token
	allocate(1);
	# Parsing global statement
	if (a1 == TOKEN_GLOBAL) { return(global_statement(a0)); };
	# Parsing include statement
	if (a1 == TOKEN_INCLUDE) { return(include_statement(a0)); };
	# Parsing statements starting with identifier
	if (a1 == TOKEN_IDENTIFIER) {
		# Fetching next token
		x0 = parser_lex(a0);
		# Parsing macro definition
		if (x0 == TOKEN_AR) { return(macro_declaration(a0)); };
		# Parsing identifier declarations
		if (x0 == ':') {
			# Fetching next token
			x0 = parser_lex(a0);
			# Parsing function declaration
			if (x0 == '(') { return(function_declaration(a0)); };
			# Parsing array declaration
			if (x0 == '[') { return(array_declaration(a0)); };
			# Parsing reserved char array declaration
			if (x0 == TOKEN_TYPE_CHAR) { return(char_array_declaration(a0)); };
			# Parsing reserved int array declaration
			if (x0 == TOKEN_TYPE_INT) { return(int_array_declaration(a0)); };
			# Parsing simple variable declaration
			return(variable_declaration(a0, x0));
		};
	};
	# For test purposes, returning expression statement
	return(expression(a0, a1));
	parser_error(a0, "Couldn't parse statement");
};

## Parse global statement
# a0 - parser
# @return statement
global_statement : (a0) {
	# x0 - op1 vector
	# x1 - next token
	# x2 - identifier
	allocate(3);
	# Allocating op1 vector
	x0 = vector(0, 1);
	# Fetching next token
	x1 = parser_lex(a0);
	# If next token is identifier - globalling only one identifier
	if (x1 == TOKEN_IDENTIFIER) {
		# Making a copy of identifier
		x2 = strdup(lexer_token_text(parser_lexer(a0)));
		# Pushing identifier to op1
		vector_push(x0, x2);
	} else {
		# If not an identifier, check if it is (. If not, errorring.
		if (x1 == '(') {
label global_statement_next;
			# Fetching next token
			x1 = parser_lex(a0);
			# Checking if it is identifier
			if (x1 != TOKEN_IDENTIFIER) { goto &global_statement_invalid; };
			# Making a copy of identifier
			x2 = strdup(lexer_token_text(parser_lexer(a0)));
			# Pushing identifier to op1
			vector_push(x0, x2);
			## If next token is , - redoing loop
			# Fetching next token
			x1 = parser_lex(a0);
			if (x1 == ',') { goto &global_statement_next; };
			# Checking for correct syntax
			if (x1 != ')') { goto &global_statement_invalid; };
		} else { goto &global_statement_invalid; };
	};
	# Returning statement
	return(tuple2(STATEMENT_GLOBAL, x0));
label global_statement_invalid;
	parser_error(a0, "Invalid global statement");
};

## Parse include statement
# a0 - parser
# @return NULL
include_statement : (a0) {
	# x0 - file vector
	# x1 - next token/i
	# x2 - file
	allocate(3);
	# Allocating files vector
	x0 = vector(0, 1);
	# Fetching next token
	x1 = parser_lex(a0);
	# If next token is string - importing one file
	if (x1 == TOKEN_STRING) {
		# Making a copy of data in string
		x2 = strlitdup(lexer_token_text(parser_lexer(a0)));
		# Pushing file to vector
		vector_push(x0, x2);
	} else {
		# If not an string, check if it is (. If not, erroring.
		if (x1 == '(') {
label include_statement_next;
			# Fetching next token
			x1 = parser_lex(a0);
			# Checking if it is string
			if (x1 != TOKEN_STRING) { goto &include_statement_invalid; };
			# Making a copy of data in string
			x2 = strlitdup(lexer_token_text(parser_lexer(a0)));
			# Pushing file to vector
			vector_push(x0, x2);
			## If next token is , - redoing loop
			# Fetching next token
			x1 = parser_lex(a0);
			if (x1 == ',') { goto &include_statement_next; };
			# Checking for correct syntax
			if (x1 != ')') { goto &include_statement_invalid; };
		} else { goto &include_statement_invalid; };
	};

	# Creating lexers for specified files
	x1 = 0;
	while (x1 < vector_size(x0)) {
		# Getting filename
		x2 = vector_get(x0, x1);
		# Adding lexer to list
		a0[PARSER_LEX] = list_insert(a0[PARSER_LEX], lexer_file(x2));
		# Moving to next file
		x1 = x1 + 1;
	};
	# Marking we switched file
	a0[PARSER_SWITCH] = TRUE;
	return(NULL);
label include_statement_invalid;
	parser_error(a0, "Invalid include statement");
};

## Parse macro declaration
# a0 - parser
# @return statement
macro_declaration : (a0) {
	# TODO: implement macro declaration
	parser_error(a0, "declarations of macros are not implemented yet");
};

## Parse function declaration
# a0 - parser
# @return statement
function_declaration : (a0) {
	# TODO: implement function declaration
	parser_error(a0, "declarations of functions are not implemented yet");
};

## Parse array declaration
# a0 - parser
# @return statement
array_declaration : (a0) {
	# TODO: implement array declaration
	parser_error(a0, "declarations of arrays are not implemented yet");
};

## Parse char array declaration
# a0 - parser
# @return statement
char_array_declaration : (a0) {
	# TODO: implement char array declaration
	parser_error(a0, "declarations of char arrays are not implemented yet");
};

## Parse int array declaration
# a0 - parser
# @return statement
int_array_declaration : (a0) {
	# TODO: implement int array declaration
	parser_error(a0, "declarations of int arrays are not implemented yet");
};

## Parse variable declaration
# a0 - parser
# a1 - current token
# @return statement
variable_declaration : (a0, a1) {
	# TODO: implement variable declaration
	parser_error(a0, "declarations of variables are not implemented yet");
};

## Parse expression
# a0 - parser
# a1 - current token
# @return statement
expression : (a0, a1) { return(ternary_expression(a0, a1)); };

## Parse ternary expression
# a0 - parser
# a1 - current token
# @return statement
ternary_expression : (a0, a1) { return(logical_or_expression(a0, a1)); };

## Parse logical or expression
# a0 - parser
# a1 - current token
# @return statement
logical_or_expression : (a0, a1) { return(logical_and_expression(a0, a1)); };

## Parse logical and expression
# a0 - parser
# a1 - current token
# @return statement
logical_and_expression : (a0, a1) { return(bitwise_or_expression(a0, a1)); };

## Parse bitwise or expression
# a0 - parser
# a1 - current token
# @return statement
bitwise_or_expression : (a0, a1) { return(bitwise_xor_expression(a0, a1)); };

## Parse bitwise xor expression
# a0 - parser
# a1 - current token
# @return statement
bitwise_xor_expression : (a0, a1) { return(bitwise_and_expression(a0, a1)); };

## Parse bitwise and expression
# a0 - parser
# a1 - current token
# @return statement
bitwise_and_expression : (a0, a1) { return(equality_expression(a0, a1)); };

## Parse equality expression
# a0 - parser
# a1 - current token
# @return statement
equality_expression : (a0, a1) { return(relational_expression(a0, a1)); };

## Parse relational expression
# a0 - parser
# a1 - current token
# @return statement
relational_expression : (a0, a1) { return(bitwise_shift_expression(a0, a1)); };

## Parse bitwise shift expression
# a0 - parser
# a1 - current token
# @return statement
bitwise_shift_expression : (a0, a1) { return(additive_expression(a0, a1)); };

## Parse additive expression
# a0 - parser
# a1 - current token
# @return statement
additive_expression : (a0, a1) { return(multiplicative_expression(a0, a1)); };

## Parse multiplicative expression
# a0 - parser
# a1 - current token
# @return statement
multiplicative_expression : (a0, a1) { return(prefix_expression(a0, a1)); };

## Parse prefix expression
# a0 - parser
# a1 - current token
# @return statement
prefix_expression : (a0, a1) { return(simple_expression(a0, a1)); };

## Parse simple expression
# a0 - parser
# a1 - current token
# @return statement
simple_expression : (a0, a1) {
	parser_error(a0, "Expressions are not fully implemented yet");
};

## Print usage
# a0 - program name
usage : (a0) {
	eputs("usage: ");
	eputs(a0);
	eputs(" [option]... <file>\n");
};

## Main function
# a0 - argc
# a1 - argv
# @return exit code
main : (a0, a1) {
	# x0 - input channel
	# x1 - lexer
	# x2 - parser
	# x3 - AST
	# x4 - i
	# x5 - j
	allocate(6);
	# If no additional args - printing usage
	if (a0 < 2) { usage(a1[0]); return(1); };
	# TODO: implement option parser
	# Creating input channel
	x0 = input_chan_file(a1[1]);
	# Creating lexer
	x1 = lexer(x0, a1[1]);
	# Creating parser
	x2 = parser(x1);
	# Print address in memory of AST
	x3 = parser_parse(x2);
	x4 = 0;
	while (x4 < vector_size(x3)) {
		puts("Node #");
		putd(x3[VEC_BUF][x4][NODE_TYPE]);
		puts(": op1=[");
		x5 = 0;
		while (x5 < vector_size(x3[VEC_BUF][x4][NODE_OP1])) {
			if (x5 != 0) { puts(", "); };
			puts(x3[VEC_BUF][x4][NODE_OP1][VEC_BUF][x5]);
			x5 = x5 + 1;
		};
		puts("]\n");
		x4 = x4 + 1;
	};
	return(a0);
};

# Entry point of the entire program
global _start;
_start : () {
	# Initializing I/O at the start
	initialize_io();
	# argc is located in 4(%esp), argv is located in 8(%esp)
	exit(main(*(&a0 - 4), &a0));
};
