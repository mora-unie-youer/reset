### Useful constants
NULL  => 0;
## Booleans
FALSE => 0;
TRUE  => 1;

### System calls
SYS_exit   => 1;
SYS_read   => 3;
SYS_write  => 4;
SYS_open   => 5;
SYS_brk    => 45;
SYS_munmap => 91;
SYS_mmap2  => 192;

### System call functions
## Exit with code
# a0 - exit code
exit : (a0) { syscall(SYS_exit, a0); };

## Read from file
# a0 - file
# a1 - buffer
# a2 - count
# @return read count
read : (a0, a1, a2) { return syscall(SYS_read, a0, a1, a2); };

## Write to file
# a0 - file
# a1 - buffer
# a2 - count
# @return write count
write : (a0, a1, a2) { return syscall(SYS_write, a0, a1, a2); };

## Open file
# a0 - path
# a1 - flags
# @return fd or error
open : (a0, a1) { return syscall(SYS_open, a0, a1); };

## Set/return heap segment limit
# a0 - address (set) or NULL (return)
# @return current heap limit
brk : (a0) { return syscall(SYS_brk, a0); };

## Unmap memory page
# a0 - address
# a1 - size
# @return zero on success, negative on error
munmap : (a0, a1) { return syscall(SYS_munmap, a0, a1); };

## Map memory page
# a0 - address
# a1 - size
# a2 - protection flags
# a3 - map flags
# a4 - fd
# a5 - offset
mmap2 : (a0, a1, a2, a3, a4, a5) {
	return syscall(SYS_mmap2, a0, a1, a2, a3, a4, a5);
};

### Useful functions
## Align number up to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align : (a0, a1) {
	return((a0 + a1 - 1) & ~(a1 - 1));
};

## Align number down to another number (which is power of 2)
# a0 - number to be aligned
# a1 - number align to
# @return aligned number
align_down : (a0, a1) {
	return(a0 - (a0 & (a1 - 1)));
};

### Conversions
## Int to string
# a0 - value
# a1 - result buffer
# a2 - base
itoa_digits : "0123456789abcdefghijklmnopqrstuvwxyz";
itoa : (a0, a1, a2) {
	# x0 - i
	# x1 - j
	# x2 - tmp
	allocate(3);
	x0 = 0;
	x1 = 0;

	# Writing first digit
	writechar(a1, x0, readchar(itoa_digits, a0 % a2));
	# Going to next unit
	a0 = a0 / a2;
	# Going to next char position
	x0 = x0 + 1;

	# Iterating while value is not zero
	while (a0 != 0) {
		# Writing needed char to result buffer
		writechar(a1, x0, readchar(itoa_digits, a0 % a2));
		# Going to next unit
		a0 = a0 / a2;
		# Going to next char position
		x0 = x0 + 1;
	};
	# Writing '\0' to the end of string
	writechar(a1, x0, '\0');
	# Reversing string
	while (x1 < x0) {
		# Starting from penultimate char
		x0 = x0 - 1;
		# Storing char to temp
		x2 = readchar(a1, x1);
		# Moving a1[x0] to a1[x1]
		writechar(a1, x1, readchar(a1, x0));
		# Moving temp to a1[x0]
		writechar(a1, x0, x2);
		# Reversing next chars
		x1 = x1 + 1;
	};
	# Returning result buffer
	return(a1);
};

### Memory Management
## Memory page size
PAGE_SIZE => 4096; # 0x1000
## Memory page status
PAGE_USED => 2147483648; # 0x80000000
## Heap segment start and end
brk_start : NULL;
brk_end   : NULL;
## Memory page list
memory_block : NULL;

## Increment heap segment size
# a0 - increment size (use negative to decrement)
# @return new heap segment limit
sbrk : (a0) {
	# x0 - old limit
	# x1 - new limit
	allocate(2);
	x0 = brk_end;
	# Uninitialized heap
	if (x0 == NULL) {
		x0 = brk(NULL);
		brk_start = x0;
	};
	# Incrementing/decrementing limit
	x1 = x0 + a0;
	# TODO: handle error, when x0 (new brk_end) < brk_start
	# Setting and returning new heap segment limit
	brk_end = x1;
	brk(x1);
	return x0;
};

## Allocate new memory page
allocate_page : () {
	# x0 - previous heap limit
	# x1 - memory size
	allocate(2);
	# Allocating next page
	x0 = sbrk(PAGE_SIZE);

	# If memory blocks are uninitialized
	if (memory_block == NULL) {
		# Initializing pointers
		memory_block = x0;
		# Initializing first memory block
		memory_block[0] = NULL; # Pointer to previous block
		memory_block[1] = PAGE_SIZE - 8; # Setting size and `not allocated`
	} else {
		x1 = memory_block[1];
		# If last memory block is used
		if (x1 & PAGE_USED) {
			# Creating new memory block
			x0[0] = memory_block; # Points to last block
			x0[1] = PAGE_SIZE - 8; # Setting size and `not allocated`
			memory_block = x0; # Setting new last block
		} else {
			# Memory block is not used, just adding new memory to it
			memory_block[1] = x1 + PAGE_SIZE;
		};
	};
};

## Allocate block
# a0 - block size
# @return address of block
allocate_block : (a0) {
	# x0 - required memory size
	# x1 - memory block
	# x2 - memory block size and status
	# x3 - new memory block
	allocate(4);
	# required size is aligned to 4 bytes
	x0 = align(a0, 4);
label allocate_block_retry;
	# Starting from latest block
	x1 = memory_block;
	# Iterating while we have next memory blocks
	while (x1 != NULL) {
		# Fetching block size and status
		x2 = x1[1];
		# Checking if this block is not used
		if ((x2 & PAGE_USED) == NULL) {
			# Checking if this block perfectly fits -> simply change status
			if (x2 == x0) {
				# Setting used status
				x1[1] = x2 | PAGE_USED;
				# Returning allocated block (skipping 8 bytes)
				return(x1 + 8);
			};
			# Checking if this block can be splitted (requested size + header size)
			if (x2 >= x0 + 8) {
				# New free block
				x3 = x1 + x0 + 8;
				x3[0] = x1; # Setting previous block
				x3[1] = x2 - x0 - 8; # Setting new size
				# If x1 is last block -> changing last block
				if (x1 == memory_block) { memory_block = x3; };
				# Decreasing block size and setting used status
				x1[1] = x0 | PAGE_USED;
				return(x1 + 8);
			};
		};
		# Iterating with next block
		x1 = x1[0];
	};
	# We are here only if there's no available block. Allocating new page
	allocate_page();
	# Now we have more memory, retrying
	goto &allocate_block_retry;
};

### Memory/String operations
## Fill memory block with value (char)
# a0 - value
# a1 - address
# a2 - size
memset : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	# Writing value to memory block
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, a0);
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Copy data from one memory block to another
# a0 - src
# a1 - dest
# a2 - size
memcpy : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, readchar(a0, x0));
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Get length of string
# a0 - string
# @return string length
strlen : (a0) {
	# x0 - string length
	allocate(1);
	x0 = 0;
	# While char is not NULL, incrementing length
	while (readchar(a0, x0) != '\0') { x0 = x0 + 1; };
	return x0;
};

## Copy string
# a0 - src
# a1 - dest
strcpy : (a0, a1) {
	# x0 - pos
	# x1 - char
	allocate(2);
	x0 = 0;
	# Reading char from string
	x1 = readchar(a0, x0);
	# Checking if char is not NULL
	while (x1 != '\0') {
		# Copying char from one string to another
		writechar(a1, x0, x1);
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
	};
	# Writing NULL character
	writechar(a1, x0, '\0');
};

## Compare string
# a0 - first string
# a1 - second string
# @return difference between different chars (0 if strings are equal)
strcmp : (a0, a1) {
	# x0 - pos
	# x1 - char from first string
	# x2 - char from second string
	allocate(3);
	x0 = 0;
	# Reading first chars from strings
	x1 = readchar(a0, x0);
	x2 = readchar(a1, x0);
	# Comparing char by char
	while (x1 != '\0') {
		if (x1 != x2) { return(x1 - x2); };
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
		x2 = readchar(a1, x0);
	};
	# As first string ended, finding the difference between ending chars
	return(x1 - x2);
};

## Main function
# a0 - argc
# a1 - argv
# @return exit code
main : (a0, a1) {
	return(a0);
};

# Entry point of the entire program
global _start;
_start : () {
	# argc is located in 4(%esp), argv is located in 8(%esp)
	exit(main(*(&a0 - 4), &a0));
};
