### Useful constants
NULL  => 0;
## Booleans
FALSE => 0;
TRUE  => 1;

### System calls
SYS_exit   => 1;
SYS_read   => 3;
SYS_write  => 4;
SYS_open   => 5;
SYS_munmap => 91;
SYS_mmap2  => 192;

### System call functions
## Exit with code
# a0 - exit code
exit : (a0) { syscall(SYS_exit, a0); };

## Read from file
# a0 - file
# a1 - buffer
# a2 - count
# @return read count
read : (a0, a1, a2) { return syscall(SYS_read, a0, a1, a2); };

## Write to file
# a0 - file
# a1 - buffer
# a2 - count
# @return write count
write : (a0, a1, a2) { return syscall(SYS_write, a0, a1, a2); };

## Open file
# a0 - path
# a1 - flags
# @return fd or error
open : (a0, a1) { return syscall(SYS_open, a0, a1); };

## Unmap memory page
# a0 - address
# a1 - size
# @return zero on success, negative on error
munmap : (a0, a1) { return syscall(SYS_munmap, a0, a1); };

## Map memory page
# a0 - address
# a1 - size
# a2 - protection flags
# a3 - map flags
# a4 - fd
# a5 - offset
mmap2 : (a0, a1, a2, a3, a4, a5) {
	return syscall(SYS_mmap2, a0, a1, a2, a3, a4, a5);
};

### Conversions
## Int to string
# a0 - value
# a1 - result buffer
# a2 - base
itoa_digits : "0123456789abcdefghijklmnopqrstuvwxyz";
itoa : (a0, a1, a2) {
	# x0 - i
	# x1 - j
	# x2 - tmp
	allocate(3);
	x0 = 0;
	x1 = 0;
	# Iterating while value is not zero
	while (a0 != 0) {
		# Writing needed char to result buffer
		writechar(a1, x0, readchar(itoa_digits, a0 % a2));
		# Going to next unit
		a0 = a0 / a2;
		# Going to next char position
		x0 = x0 + 1;
	};
	# Writing '\0' to the end of string
	writechar(a1, x0, '\0');
	# Reversing string
	while (x1 < x0) {
		# Starting from penultimate char
		x0 = x0 - 1;
		# Storing char to temp
		x2 = readchar(a1, x1);
		# Moving a1[x0] to a1[x1]
		writechar(a1, x1, readchar(a1, x0));
		# Moving temp to a1[x0]
		writechar(a1, x0, x2);
		# Reversing next chars
		x1 = x1 + 1;
	};
	# Returning result buffer
	return(a1);
};

### Memory/String operations
## Fill memory block with value (char)
# a0 - value
# a1 - address
# a2 - size
memset : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	# Writing value to memory block
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, a0);
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Copy data from one memory block to another
# a0 - src
# a1 - dest
# a2 - size
memcpy : (a0, a1, a2) {
	# x0 - pos
	allocate(1);
	x0 = 0;
	while (x0 < a2) {
		# Writing byte
		writechar(a1, x0, readchar(a0, x0));
		# Moving to next byte
		x0 = x0 + 1;
	};
};

## Get length of string
# a0 - string
# @return string length
strlen : (a0) {
	# x0 - string length
	allocate(1);
	x0 = 0;
	# While char is not NULL, incrementing length
	while (readchar(a0, x0) != '\0') { x0 = x0 + 1; };
	return x0;
};

## Copy string
# a0 - src
# a1 - dest
strcpy : (a0, a1) {
	# x0 - pos
	# x1 - char
	allocate(2);
	x0 = 0;
	# Reading char from string
	x1 = readchar(a0, x0);
	# Checking if char is not NULL
	while (x1 != '\0') {
		# Copying char from one string to another
		writechar(a1, x0, x1);
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
	};
	# Writing NULL character
	writechar(a1, x0, '\0');
};

## Compare string
# a0 - first string
# a1 - second string
# @return difference between different chars (0 if strings are equal)
strcmp : (a0, a1) {
	# x0 - pos
	# x1 - char from first string
	# x2 - char from second string
	allocate(3);
	x0 = 0;
	# Reading first chars from strings
	x1 = readchar(a0, x0);
	x2 = readchar(a1, x0);
	# Comparing char by char
	while (x1 != '\0') {
		if (x1 != x2) { return(x1 - x2); };
		# Moving to next char
		x0 = x0 + 1;
		# Reading next char
		x1 = readchar(a0, x0);
		x2 = readchar(a1, x0);
	};
	# As first string ended, finding the difference between ending chars
	return(x1 - x2);
};

## Main function
# a0 - argc
# a1 - argv
# @return exit code
main : (a0, a1) {
	return(a0);
};

# Entry point of the entire program
global _start;
_start : () {
	# argc is located in 4(%esp), argv is located in 8(%esp)
	exit(main(*(&a0 - 4), &a0));
};
